{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>NSPS Connector Implementation Guide provides implementation and configuration guidance for partners wishing to integrate their connectors with the NSPS using Docker microservices. Please note that it does not cover topics such as monitoring, high availability, disaster recovery, or other operational and infrastructure-related aspects. These areas are considered out of scope and are the responsibility of the solution architect overseeing the connector\u2019s deployment and maintenance.</p>"},{"location":"index.html#provisioning-system-overview","title":"Provisioning System Overview","text":"<p>The system consists of:</p> <ul> <li>PortaBilling: Generates minimal events (e.g., customer creation, service activation) and sends them via webhooks.</li> <li>Cloud Provider: Represents the infrastructure environment (such as GCP, OCI, AWS, etc.) where the NSPS system is deployed. It provides essential cloud services for monitoring, logging, and hosting all system components. This ensures scalability, reliability, and observability of the entire provisioning system.</li> <li>External Network Systems (e.g. HSS, PCRF etc): Requires updates based on the events received, with each system having its own proprietary API.</li> <li>NSPS (New Service Provisioning System): Processes events, enriches data, and provisions the necessary external network systems.</li> </ul> <p>The primary goal of the NSPS is to automate the provisioning and service updates of external network systems triggered by changes within PortaBilling. This includes some similar tasks such as service activation, deactivation, and configuration updates. NSPS is aimed to provide an alternative and light-weight tool for cloud provisioning to cover some basic flows. If some fancy workflow logic is needed - it's worth to consider PortaOne Workflows solution instead.</p> <p>The connector is a service that receives events enriched by NSPS from PortaBilling, selects the necessary parameters, and sends them to the external system in the format required by that external system.</p> <p>The interaction of the components is shown in the diagram below.</p> <pre><code>flowchart LR\n    A[PortaBilling] --&gt;|Event| B\n    B &lt;--&gt;|Enrich event with SIM, Account, etc.| A\n    B --&gt;|Send enriched event| C\n    C --&gt;|Provision| D[External Systems]\n    subgraph Cloud1[Google Cloud]\n        B[NSPS]\n    end\n    subgraph Cloud2[Google Cloud, Azure, Amazon, etc.]\n        C{Connector}\n    end</code></pre>"},{"location":"connector-overview.html","title":"Connector Overview","text":"<p>Connectors are specialized adapter microservices that translate events from the NSPS system into format-specific requests required by external network systems. Each external system integration requires a dedicated connector implementation.</p>"},{"location":"connector-overview.html#key-responsibilities","title":"Key Responsibilities","text":"<ul> <li>Receiving events from NSPS.</li> <li>Data transformation and mapping from NSPS event format to external system format.</li> <li>Authentication with external systems.</li> <li>Error handling and status reporting.</li> <li>Logging of interactions with external systems.</li> </ul>"},{"location":"deployment.html","title":"Deployment","text":"<p>Since the connector is designed as a Docker microservice, it can be deployed in any cloud, for example, using a cloud-specific utility. Below are examples of scripts that you can use, but you can write your own that are simpler or more complex to suit your needs.</p> <p>Note</p> <ul> <li>Hosting expenses for your connectors deployed in cloud platforms won't be covered by PortaOne.</li> <li>There is a local deployment option, at no extra cost, to consider:<ul> <li>assuming test purposes or development - local PC/laptop;</li> <li>assuming production but low traffic / load (otherwise, extra server(s) is required to handle the load): [Docker Swarm managed via PortaBilling Portainer Stack][docker-swarm].</li> </ul> </li> </ul> <p>Example for GCP: deploy as a Cloud Run. Official guide on how to deploy Cloud Run services you can find here.</p> <p>A Cloud Run service URL typically follows the format: <code>https://[TAG---]SERVICE_IDENTIFIER.run.app</code>. <code>SERVICE_IDENTIFIER</code> is a unique, stable identifier for the service, and the TAG refers to the traffic tag of the specific revision. The <code>SERVICE_IDENTIFIER</code> includes a random string and the region shortcut.</p> <p><code>https://[TAG---]SERVICE_NAME-PROJECT_NUMBER.REGION.run.app</code></p> <p>where:</p> <ul> <li>TAG is the optional traffic tag for the revision that you are requesting.</li> <li>PROJECT_NUMBER is the Google Cloud project number.</li> <li>SERVICE_NAME is the name of the Cloud Run service.</li> <li>REGION is the name of the region, such as <code>us-central1</code>.</li> </ul> <p>Example for AWS: deploy as an App Runner. Official guide on how to deploy App Runner services you can find here.</p> <p>An App Runner service URL typically follows the format: <code>https://[service-id].[region].awsapprunner.com</code> where <code>service-id</code> is a unique identifier for your service and <code>region</code> is the AWS region where your service is hosted.</p> <p>For example: <code>https://abcd1234efgh.us-east-1.awsapprunner.com</code></p>"},{"location":"deployment.html#infrastructure-considerations","title":"Infrastructure Considerations","text":"<p>The default deployment of NSPS, PortaBilling, and Connector/Core is intended to run in a public internet environment, where services can communicate freely over the network. However, in specific cases, it may be necessary to restrict public access to components for security reasons.</p> <p>At this time, we can provide a static IP address used by NSPS to make requests to both the Connector and PortaBilling.</p> <p>VPN connectivity is not currently supported and is under consideration (DO-5364).</p>"},{"location":"get-started.html","title":"Get Started","text":""},{"location":"get-started.html#nsps-preparation","title":"NSPS Preparation","text":"<p>Configure a Handler in the NSPS system before creating a connector. The Handler is responsible for sending events to the connector server. Specify the following parameters during setup:</p> <ol> <li> <p>Event Types    The types of events your connector will receive. More details here: Event Types</p> </li> <li> <p>Required Data    Additional data that NSPS will add to the event. More details here: Request Body</p> </li> <li> <p>Service URL    The address of your connector where NSPS will send events.    For example: <code>https://my-server.com/my-event</code></p> </li> <li> <p>Bearer Token    For security, all requests from NSPS are signed with a token.    Your connector must verify this token in every request using the header: <code>Authorization: Bearer &lt;your_token&gt;</code></p> </li> </ol> <p>After configuring the Handler in NSPS, you are ready to proceed to creating your own connector.</p>"},{"location":"get-started.html#creating-an-nsps-connector","title":"Creating an NSPS Connector","text":"<p>Before you start, we recommend reviewing the original repository:</p> TypeScriptPython <p>NSPS Connector Example (TypeScript/Express)</p> <p>NSPS Connector Example (Python/FastAPI)</p> <p>In this section you will learn how to:</p> <ul> <li>create a server that receives events from NSPS;</li> <li>add a <code>/process-event</code> route to handle these events;</li> <li>verify the Bearer Token in requests;</li> <li>process and print the required data to the console;</li> <li>send a response in the format expected by NSPS.</li> </ul>"},{"location":"get-started.html#dependencies","title":"Dependencies","text":"<p>This project uses third-party libraries and services required for the connector to work:</p> TypeScriptPython package.json<pre><code>\"dependencies\": {\n    \"dotenv\": \"^17.2.3\",\n    \"express\": \"^5.1.0\"\n},\n\"devDependencies\": {\n    \"@types/express\": \"^5.0.3\",\n    \"@types/node\": \"^24.6.2\",\n    \"nodemon\": \"^3.1.10\",\n    \"typescript\": \"^5.9.3\"\n},\n</code></pre> requirements.txt<pre><code>fastapi==0.118.0\nuvicorn[standard]==0.37.0\npython-dotenv==1.1.1\n</code></pre>"},{"location":"get-started.html#server-setup","title":"Server Setup","text":"<p>First, create a server that listens on a specific port (for example, <code>3000</code>) and add a basic <code>/process-event</code> route.</p> <p>Important! Create a <code>.env</code> file in the project root and add the following variables:</p> .env<pre><code>API_TOKEN=your_secret_token\nPORT=3000\n</code></pre> <p>Replace <code>your_secret_token</code> with your own token that you will specify in the NSPS Handler.</p> TypeScriptPython index.ts<pre><code>  import express from 'express';\n  import type { Request, Response, NextFunction } from 'express';\n  import dotenv from 'dotenv';\n\n  dotenv.config();\n\n  const app = express();\n  app.use(express.json());\n\n  const API_TOKEN = process.env.API_TOKEN || 'your-secret-token';\n  const PORT = process.env.PORT ? Number(process.env.PORT) : 3000;\n\n  app.post('/process-event', (req: Request, res: Response) =&gt; {\n      res.status(202).json({ message: 'Event accepted for processing' });\n  });\n\n  app.listen(PORT, () =&gt; {\n      console.log(`Connector listening on port ${PORT}`);\n  });\n</code></pre> main.py<pre><code>import os\nfrom fastapi import FastAPI, Request, HTTPException, status, Depends\nfrom fastapi.responses import JSONResponse\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\napp = FastAPI()\n\nAPI_TOKEN = os.getenv(\"API_TOKEN\", \"your-secret-token\")\nPORT = int(os.getenv(\"PORT\", 3000))\n\n\n@app.post(\"/process-event\")\nasync def process_event(\n    request: Request,\n):\n    return JSONResponse(\n        status_code=status.HTTP_202_ACCEPTED,\n        content={\"message\": \"Event accepted for processing\"},\n    )\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=PORT, reload=True)\n    print(f\"Connector listening on port {PORT}\")\n</code></pre>"},{"location":"get-started.html#token-verification","title":"Token Verification","text":"<p>To ensure security, NSPS always sends the token in the Authorization header. Your connector must verify it before processing the event.</p> TypeScriptPython index.ts<pre><code>function verifyBearerToken(req: Request, res: Response, next: NextFunction) {\n    const auth = req.headers['authorization'] || '';\n    const token = auth.replace('Bearer ', '');\n    if (!auth.toString().startsWith('Bearer ') || token !== API_TOKEN) {\n        return res.status(401).json({\n            message: 'Authentication failed',\n            error: 'Invalid API token',\n            type: 'AUTHENTICATION_ERROR',\n        });\n    }\n    next();\n}\n\napp.post('/process-event', verifyBearerToken, (req: Request, res: Response) =&gt; {\n    res.status(202).json({ message: 'Event accepted for processing' });\n});\n</code></pre> main.py<pre><code>bearer_scheme = HTTPBearer()\n\n\ndef verify_bearer_token(\n    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),\n):\n    token = credentials.credentials\n    if token != API_TOKEN:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail={\n                \"message\": \"Authentication failed\",\n                \"error\": \"Invalid API token\",\n                \"type\": \"AUTHENTICATION_ERROR\",\n            },\n        )\n\n\n@app.post(\"/process-event\")\nasync def process_event(\n    request: Request,\n    credentials: HTTPAuthorizationCredentials = Depends(verify_bearer_token),\n):\n    return JSONResponse(\n        status_code=status.HTTP_202_ACCEPTED,\n        content={\"message\": \"Event accepted for processing\"},\n    )\n</code></pre>"},{"location":"get-started.html#event-processing","title":"Event Processing","text":"<p>You can extract the required data from the event body (for example, <code>eventType</code> and <code>billStatus</code>). In the example below, this data is simply printed to the console. At this stage, you can implement your own business logic: send data to an external system, save it to a database, etc.</p> TypeScriptPython index.ts<pre><code>app.post('/process-event', verifyBearerToken, (req: Request, res: Response) =&gt; {\n    const { data, pb_data } = req.body;\n\n    const eventType = data?.event_type;\n    const billStatus = pb_data?.account_info?.bill_status;\n\n    if (!eventType || !billStatus) {\n        return res.status(422).json({\n            message: 'Validation failed',\n            error: 'Validation failed',\n            type: 'VALIDATION_ERROR',\n        });\n    }\n\n    console.log('Received event:', eventType, '| bill status:', billStatus);\n\n    res.status(202).json({ message: 'Event accepted for processing' });\n});\n</code></pre> main.py<pre><code>@app.post(\"/process-event\")\nasync def process_event(\n    request: Request,\n    credentials: HTTPAuthorizationCredentials = Depends(verify_bearer_token),\n):\n    body = await request.json()\n    data = body.get(\"data\", {})\n    pb_data = body.get(\"pb_data\", {})\n    event_type = data.get(\"event_type\")\n    bill_status = pb_data.get(\"account_info\", {}).get(\"bill_status\")\n\n    if not event_type or not bill_status:\n        return JSONResponse(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            content={\n                \"message\": \"Validation failed\",\n                \"error\": \"Validation failed\",\n                \"type\": \"VALIDATION_ERROR\",\n            },\n        )\n\n    print(f\"Received event: {event_type} | bill status: {bill_status}\")\n\n    return JSONResponse(\n        status_code=status.HTTP_202_ACCEPTED,\n        content={\"message\": \"Event accepted for processing\"},\n    )\n</code></pre>"},{"location":"get-started.html#testing","title":"Testing","text":"<p>This section shows what a test request from NSPS looks like, what response the connector returns, and what will be displayed in the console.</p>"},{"location":"get-started.html#1-example-message-from-nsps","title":"1. Example message from NSPS","text":"<p>Testing can be performed without NSPS by simulating a typical NSPS request.</p> <p>See more about the structure in Request Body</p> Example bash<pre><code>curl -X POST http://localhost:8000/process-event \\\n  -H \"Authorization: Bearer your-api-token\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"event_id\": \"3e84c79f-ab6f-4546-8e27-0b6ab866f1fb\",\n    \"data\": {\n      \"event_type\": \"SIM/Updated\",\n      \"variables\": {\n        \"i_env\": 1,\n        \"i_event\": 999999,\n        \"i_account\": 1,\n        \"curr_status\": \"used\",\n        \"prev_status\": \"active\"\n      }\n    },\n    \"pb_data\": {\n      \"account_info\": {\n        \"bill_status\": \"open\",\n        \"billing_model\": \"credit_account\",\n        \"blocked\": false,\n        \"i_account\": 1,\n        \"i_customer\": 6392,\n        \"i_product\": 3774,\n        \"id\": \"79123456789@msisdn\",\n        \"phone1\": \"\",\n        \"product_name\": \"wtl Pay as you go\",\n        \"time_zone_name\": \"Europe/Prague\",\n        \"assigned_addons\": [\n          {\n            \"addon_effective_from\": \"2025-05-16T12:59:46\",\n            \"addon_priority\": 10,\n            \"description\": \"\",\n            \"i_product\": 3775,\n            \"i_vd_plan\": 1591,\n            \"name\": \"wtl Youtube UHD\"\n          }\n        ],\n        \"service_features\": [\n          {\n            \"name\": \"netaccess_policy\",\n            \"effective_flag_value\": \"Y\",\n            \"attributes\": [\n              {\n                \"name\": \"access_policy\",\n                \"effective_value\": \"179\"\n              }\n            ]\n          }\n        ]\n      },\n      \"sim_info\": {\n        \"i_sim_card\": 3793,\n        \"imsi\": \"001010000020349\",\n        \"msisdn\": \"79123456789\",\n        \"status\": \"active\"\n      },\n      \"access_policy_info\": {\n        \"i_access_policy\": 179,\n        \"name\": \"WTL integration test\",\n        \"attributes\": [\n          {\n            \"group_name\": \"lte.wtl\",\n            \"name\": \"cs_profile\",\n            \"value\": \"cs-pp-20250319\"\n          },\n          {\n            \"group_name\": \"lte.wtl\",\n            \"name\": \"eps_profile\",\n            \"value\": \"eps-pp-20250319\"\n          }\n        ]\n      }\n    },\n    \"handler_id\": \"p1-nsps\",\n    \"created_at\": \"2025-03-12T16:47:30.443939+00:00\",\n    \"updated_at\": \"2025-03-12T16:47:36.585885+00:00\",\n    \"status\": \"received\"\n  }'\n</code></pre> <p>This example simulates a standard NSPS request and verifies that the connector processes events correctly.</p>"},{"location":"get-started.html#2-connector-response","title":"2. Connector response","text":"<p>Connector response upon successful request processing:</p> <pre><code>{\n    \"message\": \"Event processed successfully\"\n}\n</code></pre> <p>If the token is missing or invalid:</p> <pre><code>{\n    \"message\": \"Authentication failed\",\n    \"error\": \"Invalid API token\",\n    \"type\": \"AUTHENTICATION_ERROR\"\n}\n</code></pre> <p>If the request body is invalid or required fields are missing:</p> <pre><code>{\n    \"message\": \"Validation failed\",\n    \"error\": \"Validation failed\",\n    \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre>"},{"location":"get-started.html#3-what-you-will-see-in-the-console","title":"3. What you will see in the console","text":"<pre><code>Received event: SIM/Updated | bill status: open\n</code></pre> <p>See also the main documentation: NSPS connector</p>"},{"location":"mcp-instruction.html","title":"Create a Connector with AI","text":"<p>Connector can be easily created with AI help. To do this, you must provide the AI agent with the necessary documentation via an MCP server.</p>"},{"location":"mcp-instruction.html#prerequisites","title":"Prerequisites","text":"<ol> <li>An IDE that supports MCP server integration (e.g., Cursor, VS Code).</li> <li>Access to AI features in the IDE.</li> </ol>"},{"location":"mcp-instruction.html#create-a-context7-account","title":"Create a Context7 Account","text":"<ol> <li>Sign up at Context7.</li> <li>Open the <code>Dashboard</code> and in the <code>Connect</code> section, click <code>Generate a new API key</code>.  </li> <li>Copy and securely store your <code>API KEY</code>.</li> </ol>"},{"location":"mcp-instruction.html#add-an-mcp-server-to-the-ide","title":"Add an MCP Server to the IDE","text":"CursorVS Code <ol> <li>Open <code>Settings</code> \u2192 <code>Cursor Settings</code> \u2192 <code>MCP</code> \u2192 <code>Add new global MCP server</code>.</li> <li>Paste the following configuration into <code>~/.cursor/mcp.json</code> file:</li> </ol> ~/.cursor/mcp.json<pre><code>{\n  \"mcpServers\": {\n    \"context7\": {\n      \"url\": \"https://mcp.context7.com/mcp\",\n      \"headers\": {\n        \"CONTEXT7_API_KEY\": \"YOUR_API_KEY\"\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>Open <code>Extensions</code> \u2192 search for <code>@mcp</code> \u2192 <code>Browse MCP Servers</code>.</li> <li>Select <code>Context7</code> \u2192 <code>Install</code>.</li> </ol> <p>Alternatively, create a <code>.vscode/mcp.json</code> file in your workspace with the following content:</p> .vscode/mcp.json<pre><code>\"mcp\": {\n  \"servers\": {\n    \"context7\": {\n      \"type\": \"http\",\n      \"url\": \"https://mcp.context7.com/mcp\",\n      \"headers\": {\n        \"CONTEXT7_API_KEY\": \"YOUR_API_KEY\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"mcp-instruction.html#prompt-ai-to-create-a-connector","title":"Prompt AI to Create a Connector","text":"<p>Note</p> <p>MCP server tools are available only when the AI runs in Agent mode.</p> <p>Use the template below to instruct the AI. Replace the placeholders with details about your ES (external system).</p> <p>Security tip</p> <p>Do not share actual credentials in the prompt. Pass them securely through environment variables instead.</p> Prompt template<pre><code>Create a connector between NSPS and the external system &lt;ES name&gt; using the context7 library https://mogorno.github.io/NSPS-connector-docs/llms.txt.\n\nShort description: &lt;Short description of the ES&gt;\nAPI URL: &lt;ES API URL&gt;  # optional, can also be provided via environment variable\n\nAuthentication:\n- Method: &lt;auth type, e.g., API key / OAuth2 / Basic&gt;\n- Details: &lt;auth field names, headers, tokens, etc.&gt;\n\nSupported event types:\n- &lt;event type&gt;\n  - handler ID: &lt;handler ID&gt;  # optional, if multiple handlers exist\n  - required fields: &lt;required fields&gt;\n  - NSPS \u2192 ES mapping action: &lt;ES action&gt;\n  - Example request to ES API:\n    ```http\n    POST &lt;ES API endpoint&gt;\n    Authorization: &lt;Authorization header / token&gt;\n    Content-Type: &lt;Content type&gt;\n\n    {\n      \"&lt;field1&gt;\": \"&lt;value1&gt;\",\n      \"&lt;field2&gt;\": \"&lt;value2&gt;\",\n      ...\n    }\n    ```\n\nAdditional details about the ES:\n- Rate limits: &lt;info&gt;\n- Error handling: &lt;info&gt;\n- Special transformations: &lt;info&gt;\n</code></pre>"},{"location":"testing.html","title":"Testing","text":"<p>We recommend testing the connector in a controlled (artificial) environment before deploying it to production to ensure correct behavior and reliability.</p> <p>Note</p> <p>The following list contains a minimal set of test cases that should be executed. Additional tests may be required to verify the connector\u2019s specific event processing logic.</p> <p>1. Connector health check</p> <p>Input:</p> <ul> <li>Request: <code>GET /health</code></li> </ul> <p>Response:</p> <ul> <li>Response: <code>200 OK</code></li> <li>Body:    <pre><code>{}\n</code></pre></li> </ul> <p>Expected result:</p> <ul> <li>Confirms connector operational status.</li> <li>ES remains unchanged.</li> <li>Log records successful health check.</li> </ul> <p>2. Process valid event</p> <p>Input:</p> <ul> <li>Request: <code>POST /process-event</code></li> <li>Headers: valid Bearer token</li> <li>Body: valid event</li> </ul> <p>Response:</p> <ul> <li>Response: <code>202 Accepted</code></li> <li>Body:    <pre><code>{\n  \"message\": \"Event accepted for processing\"\n}\n</code></pre></li> </ul> <p>Expected result:</p> <ul> <li>Indicates normal operation and data flow.</li> <li>ES updated as expected.</li> <li>Log records event acceptance.</li> </ul> <p>3. Reject invalid or missing token</p> <p>Input:</p> <ul> <li>Request: <code>POST /process-event</code></li> <li>Headers: invalid or missing Bearer token</li> <li>Body: valid event</li> </ul> <p>Response:</p> <ul> <li>Response: <code>401 Unauthorized</code></li> <li>Body:   <pre><code>{ \n  \"message\": \"Invalid access token\", \n  \"error\": \"Unauthorized\", \n  \"type\": \"AUTHENTICATION_ERROR\" \n}\n</code></pre></li> </ul> <p>Expected result:</p> <ul> <li>Confirms authentication validation is enforced.</li> <li>ES remains unchanged.</li> <li>Log records authentication failure.</li> </ul> <p>4. Handle non-existent resource</p> <p>Input:</p> <ul> <li>Request: <code>POST /process-event</code></li> <li>Headers: valid Bearer token</li> <li>Body: event referencing unknown or deleted entity</li> </ul> <p>Response:</p> <ul> <li>Response: <code>404 Not Found</code></li> <li>Body:   <pre><code>{\n  \"message\": \"Resource not found\",\n  \"error\": \"Not found\",\n  \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre></li> </ul> <p>Expected result:</p> <ul> <li>Confirms validation of referenced entities.</li> <li>ES remains unchanged.</li> <li>Log records missing resource error.</li> </ul> <p>5. Reject unsupported HTTP method</p> <p>Input:</p> <ul> <li>Request: <code>GET /process-event</code></li> </ul> <p>Response:</p> <ul> <li>Response: <code>405 Method Not Allowed</code></li> <li>Body:   <pre><code>{\n  \"message\": \"Method not allowed\",\n  \"error\": \"Method not allowed\",\n  \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre></li> </ul> <p>Expected result:</p> <ul> <li>Validates endpoint method restrictions.</li> <li>ES remains unchanged.</li> <li>Log records invalid method attempt.</li> </ul> <p>6. Validate request schema</p> <p>Input:</p> <ul> <li>Request: <code>POST /process-event</code></li> <li>Headers: valid Bearer token</li> <li>Body: event with missing or malformed fields</li> </ul> <p>Response:</p> <ul> <li>Response: <code>422 Unprocessable Entity</code></li> <li>Body:   <pre><code>{\n  \"message\": \"Validation failed\",\n  \"error\": \"Validation failed\",\n  \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre></li> </ul> <p>Expected result:</p> <ul> <li>Confirms input schema validation is enforced.</li> <li>ES remains unchanged.</li> <li>Log records event validation failure.</li> </ul> <p>7. Enforce rate limits</p> <p>Input:</p> <ul> <li>Rapid repeated requests: <code>POST /process-event</code></li> <li>Headers: valid Bearer token</li> <li>Body: valid event</li> </ul> <p>Response:</p> <ul> <li>Response: <code>429 Too Many Requests</code></li> <li>Body:   <pre><code>{\n  \"message\": \"Too many requests to API Core\",\n  \"error\": \"Rate limit exceeded\",\n  \"type\": \"RATE_LIMIT_ERROR\"\n}\n</code></pre></li> </ul> <p>Expected result:</p> <ul> <li>Confirms rate limiting mechanism works correctly.</li> <li>ES remains unchanged.</li> <li>Log records rate limit violation.</li> </ul> <p>8. Handle internal server error</p> <p>Input:</p> <ul> <li>Forced internal exception in event handler</li> </ul> <p>Response:</p> <ul> <li>Response: <code>500 Internal Server Error</code></li> <li>Body:   <pre><code>{\n  \"message\": \"API Core HTTP error\",\n  \"error\": \"Internal server error\",\n  \"type\": \"SERVICE_ERROR\"\n}\n</code></pre></li> </ul> <p>Expected result:</p> <ul> <li>Verifies resilience to internal failures.</li> <li>ES remains unchanged.</li> <li>Log records internal error event.</li> </ul> <p>9. Handle Core service unavailability</p> <p>Input:</p> <ul> <li>Simulated timeout or Core API outage</li> </ul> <p>Response:</p> <ul> <li>Response: <code>503 Service Unavailable</code></li> <li>Body:   <pre><code>{\n  \"message\": \"Core service is not available\",\n  \"error\": \"Connection timeout\",\n  \"type\": \"CONNECTION_ERROR\"\n}\n</code></pre></li> </ul> <p>Expected result:</p> <ul> <li>Confirms correct handling of external dependency downtime.</li> <li>ES remains unchanged.</li> <li>Log records service unavailability.</li> </ul> <p>10. Graceful shutdown</p> <p>Input:</p> <ul> <li>Simulated service stop or restart</li> </ul> <p>Response:</p> <ul> <li>Response: graceful stop message or status</li> </ul> <p>Expected result:</p> <ul> <li>Verifies connector shuts down cleanly without losing in-progress tasks.</li> <li>ES remains consistent.</li> <li>Log records shutdown sequence.</li> </ul>"},{"location":"testing.html#manual-api-testing-using-curl","title":"Manual API testing using <code>curl</code>","text":"<p>After serving the connector locally, you can send test requests to it with curl:</p> <p>Note</p> <p>You can put event data in the <code>JSON</code> file for convinience, and refer to it in the request.</p> bashPowerShell <p>Health check: bash<pre><code>curl -X GET \"http://localhost:8000/health\"\n</code></pre></p> <p>Process event: bash<pre><code>curl -X POST \"http://localhost:8000/process-event\" \\\n  -H \"Authorization: Bearer &lt;YOUR_API_TOKEN&gt;\" \\\n  -H \"Content-Type: application/json\" \\\n  -d @&lt;PATH_TO_MOCK_EVENT_DATA.json&gt;\n</code></pre></p> <p>Health check: powershell<pre><code>curl -Method GET \"http://localhost:8000/health\"\n</code></pre></p> <p>Process event: powershell<pre><code>curl -Method POST \"http://localhost:8000/process-event\" `\n  -Headers @{ \"Authorization\" = \"Bearer &lt;YOUR_API_TOKEN&gt;\"; \"Content-Type\" = \"application/json\" } `\n  -Body (Get-Content \"&lt;PATH_TO_MOCK_EVENT_DATA.json&gt;\" -Raw)\n</code></pre></p> <p>For test cases #7\u20139, consider using a mock HTTP server to simulate the external system.</p> <p>Example Python mock server</p> <ol> <li> <p>Create a python script <code>mock_es.py</code>:</p> mock_es.py<pre><code>from http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass MockHandler(BaseHTTPRequestHandler):\n    def do_POST(self):\n        self.send_response(&lt;STATUS_CODE&gt;)\n        self.end_headers()\n        self.wfile.write(b'&lt;MESSAGE&gt;')\n\nif __name__ == \"__main__\":\n    HTTPServer(('0.0.0.0', 8081), MockHandler).serve_forever()\n</code></pre> </li> <li> <p>Run it with:</p> bash<pre><code>python3 mock_es.py\n</code></pre> </li> <li> <p>Update the connector configuration so that the ES URL points to <code>http://localhost:8081/test</code></p> </li> </ol> <p>This setup allows you to simulate various ES responses (e.g., 429, 500, 503) and verify that the connector handles them correctly.</p>"},{"location":"testing.html#example-mock-event-data","title":"Example mock event data","text":"Valid event <pre><code>{\n  \"event_id\": \"3e84c79f-ab6f-4546-8e27-0b6ab866f1fb\",\n  \"data\": {\n    \"event_type\": \"SIM/Updated\",\n    \"variables\": {\n      \"i_env\": 1,\n      \"i_event\": 999999,\n      \"i_account\": 1,\n      \"curr_status\": \"used\",\n      \"prev_status\": \"active\"\n    }\n  },\n  \"pb_data\": {\n    \"account_info\": {\n      \"bill_status\": \"open\",\n      \"billing_model\": \"credit_account\",\n      \"blocked\": false,\n      \"firstname\": \"Serhii\",\n      \"i_account\": 1,\n      \"i_customer\": 6392,\n      \"i_product\": 3774,\n      \"id\": \"79123456789@msisdn\",\n      \"lastname\": \"Dolhopolov\",\n      \"phone1\": \"\",\n      \"product_name\": \"Pay as you go\",\n      \"time_zone_name\": \"Europe/Prague\",\n      \"assigned_addons\": [\n        {\n          \"addon_effective_from\": \"2025-05-16T12:59:46\",\n          \"addon_priority\": 10,\n          \"description\": \"\",\n          \"i_product\": 3775,\n          \"i_vd_plan\": 1591,\n          \"name\": \"Youtube UHD\"\n        }\n      ],\n      \"service_features\": [\n        {\n          \"name\": \"netaccess_policy\",\n          \"effective_flag_value\": \"Y\",\n          \"attributes\": [\n            {\n              \"name\": \"access_policy\",\n              \"effective_value\": \"179\"\n            }\n          ]\n        }\n      ]\n    },\n    \"sim_info\": {\n      \"i_sim_card\": 3793,\n      \"imsi\": \"001010000020349\",\n      \"msisdn\": \"79123456789\",\n      \"status\": \"active\"\n    },\n    \"access_policy_info\": {\n      \"i_access_policy\": 179,\n      \"name\": \"Integration test\",\n      \"attributes\": [\n        {\n          \"group_name\": \"lte.wtl\",\n          \"name\": \"cs_profile\",\n          \"value\": \"cs-pp-20250319\"\n        },\n        {\n          \"group_name\": \"lte.wtl\",\n          \"name\": \"eps_profile\",\n          \"value\": \"eps-pp-20250319\"\n        }\n      ]\n    }\n  },\n  \"handler_id\": \"hlr-hss-nsps\",\n  \"created_at\": \"2025-03-12T16:47:30.443939+00:00\",\n  \"updated_at\": \"2025-03-12T16:47:36.585885+00:00\",\n  \"status\": \"received\"\n}\n</code></pre> Malformed event <pre><code>{\n  \"event_id\": \"d2b93013-8a45-46d3-943b-5b65c8a1c5de\",\n  \"data\": {\n    \"event_type\": \"SIM/Updated\"\n  },\n  \"handler_id\": \"hlr-hss-nsps\",\n  \"created_at\": \"2025-03-12T16:47:30.443939+00:00\",\n  \"updated_at\": \"2025-03-12T16:47:36.585885+00:00\",\n  \"status\": \"received\"\n}\n</code></pre>"},{"location":"NSPS/data-flows.html","title":"Data Flows","text":""},{"location":"NSPS/data-flows.html#input","title":"Input","text":"<p>NSPS accepts webhook events from PortaBilling ESPF via secure HTTP. The events contain minimal information:</p> Example of ESPF event Example of ESPF event<pre><code>{\n    \"event_type\": \"SIM/Updated\",\n    \"variables\": {\n        \"i_env\": 3,\n        \"i_event\": 999999,\n        \"i_account\": 277147,\n        \"event_time\": \"2025-05-01 12:00:00\"\n    }\n}\n</code></pre> <p>Key input fields:</p> <ul> <li><code>event_type</code>: Identifies the type of event (e.g., \"Account/Unblocked\", \"SIM/Updated\").</li> <li><code>variables</code>: Contains identifiers and metadata for the event.</li> <li><code>i_event</code>: Unique event identifier in PortaBilling.</li> <li><code>i_account</code>: Account identifier affected by the event.</li> <li><code>event_time</code>: Optional timestamp when the event occurred (format: <code>YYYY-MM-DD HH:MM:SS</code> in UTC).</li> </ul> <p>The set of fields in the variables object may vary depending on the event type (<code>event_type</code>). Authentication is performed via HTTP Basic Auth with configurable credentials.</p>"},{"location":"NSPS/data-flows.html#output","title":"Output","text":"<p>NSPS outputs enriched events to connector microservices, which are responsible for interfacing with external systems. The enriched event contains all necessary data for provisioning:</p> Example of enriched event Example of enriched event<pre><code>{\n    \"event_id\":\"3e84c79f-ab6f-4546-8e27-0b6ab866f1fb\",\n    \"data\":{\n        \"event_type\":\"SIM/Updated\",\n        \"variables\":{\n            \"i_env\":1,\n            \"i_event\":999999,\n            \"i_account\":1,\n            \"curr_status\":\"used\",\n            \"prev_status\":\"active\"\n        }\n    },\n    \"pb_data\":{\n        \"account_info\":{\n            \"bill_status\":\"open\",\n            \"billing_model\":\"credit_account\",\n            \"blocked\":false,\n            \"i_account\":1,\n            \"i_customer\":6392,\n            \"i_product\":3774,\n            \"id\":\"79123456789@msisdn\",\n            \"phone1\":\"\",\n            \"product_name\":\"wtl Pay as you go\",\n            \"time_zone_name\":\"Europe/Prague\",\n            \"assigned_addons\":[\n                {\n                    \"addon_effective_from\":\"2025-05-16T12:59:46\",\n                    \"addon_priority\":10,\n                    \"description\":\"\",\n                    \"i_product\":3775,\n                    \"i_vd_plan\":1591,\n                    \"name\":\"wtl Youtube UHD\"\n                }\n            ],\n            \"service_features\":[\n                {\n                    \"name\":\"netaccess_policy\",\n                    \"effective_flag_value\":\"Y\",\n                    \"attributes\":[\n                        {\n                            \"name\":\"access_policy\",\n                            \"effective_value\":\"179\"\n                        }\n                    ]\n                }\n            ]\n        },\n        \"sim_info\":{\n            \"i_sim_card\":3793,\n            \"imsi\":\"001010000020349\",\n            \"msisdn\":\"79123456789\",\n            \"status\":\"active\"\n        },\n        \"access_policy_info\":{\n            \"i_access_policy\":179,\n            \"name\":\"WTL integration test\",\n            \"attributes\":[\n                {\n                    \"group_name\":\"lte.wtl\",\n                    \"name\":\"cs_profile\",\n                    \"value\":\"cs-pp-20250319\"\n                },\n                {\n                    \"group_name\":\"lte.wtl\",\n                    \"name\":\"eps_profile\",\n                    \"value\":\"eps-pp-20250319\"\n                }\n            ]\n        },\n        \"product_info\":{\n            \"name\":\"DEV WTL Pay as you go\",\n            \"description\":\"\",\n            \"addon_priority\":0,\n            \"i_product\":658\n        },\n        \"full_vd_counter_info\":[\n            {\n                \"service_name\":\"Internet Access KB\",\n                \"vdp_name\":\"DEV WTL Free 10MB (1 day)\",\n                \"i_vd_plan\":204,\n                \"i_dest_group\":2650,\n                \"addon_priority\":10,\n                \"i_vd_dg\":283,\n                \"remaining\":\"10\",\n                \"i_service\":106,\n                \"dg_name\":\"RG100\",\n                \"discount_info\":\"0..10 - 100%\",\n                \"unit\":\"megabyte\",\n                \"allocated_amount\":10\n            }\n        ]\n    },\n    \"handler_id\":\"wtl-hlr-hss-nsps\",\n    \"created_at\":\"2025-03-12T16:47:30.443939+00:00\",\n    \"updated_at\":\"2025-03-12T16:47:36.585885+00:00\",\n    \"status\":\"received\"\n}\n</code></pre> <p>The connectors, which are outside the NSPS black box, then transform this enriched data into formats specific to each external system. Depending on the event type and the target external system, different subsets of these fields may be used for the transformation.</p>"},{"location":"NSPS/nsps-overview.html","title":"NSPS Overview","text":"<p>The New Service Provisioning System (NSPS) is designed to receive, queue, dispatch, and enrich events from PortaBilling ESPF (External System Provisioning Framework) for delivery to external systems. The system is built on a microservice architecture and operates in the Google Cloud Platform (GCP) infrastructure.</p> <p>This service is being developed as a multi-instance solution, where the full set of components will be deployed separately for each individual customer and/or PortaBilling environment.</p>"},{"location":"NSPS/nsps-overview.html#how-it-works","title":"How It Works","text":"<ol> <li>PortaBilling generates an event (e.g., a subscriber upgrades their plan).</li> <li>The built-in ESPF sends this event to NSPS via an HTTP request (webhook).</li> <li>NSPS enriches the data it receives from PortaBilling by calling the PortaBilling API to fetch additional data, such as the product and access policy details.</li> <li>The NSPS queues the event and passes it to the connector.</li> <li>The connector communicates with the external system to apply the required changes.</li> </ol>"},{"location":"NSPS/nsps-overview.html#high-level-system-areas","title":"High-Level System Areas","text":"<ul> <li>Service Area: Event processing components for handling ESPF events and provisioning external systems.</li> <li>Management Area: Configuration and monitoring components for system administration.</li> <li>Storage Area: Persistent storage for events, configuration, and state.</li> </ul>"},{"location":"NSPS/nsps-overview.html#external-network-system","title":"External Network System","text":"<p>External Network System is any third-party platform or telecom component that must stay synchronized with PortaBilling.</p> <p>These may include business tools (e.g., CRM systems, IPTV platforms) or mobile network elements (e.g., HSS, which manages subscriber identities, and PCRF, which enforces policy and charging rules). External System may also be a database where users must be registered once they complete certain actions tracked by PortaBilling. Another example is an automated notification service that delivers messages based on events in PortaBilling.</p>"},{"location":"NSPS/technical-specifications.html","title":"Technical Specifications","text":""},{"location":"NSPS/technical-specifications.html#performance-and-scalability","title":"Performance and Scalability","text":"<ul> <li>Throughput Capacity: Supports up to 10 million mobile subscribers.</li> <li>Event Processing Time: Processes single events within 3 seconds of receipt (excluding API response time from PortaBilling and processing time on connector and external system side).</li> <li>Queue Capacity: Unlimited event buffering through cloud-based queuing (PubSub).</li> <li>Retry Capabilities:<ul> <li>Main subscription: ~24 hours of retries (100 attempts, 1-10 minutes delay).</li> <li>Long Retry: Exponential backoff with increasing intervals (1h 2h 4h 8h 16h 24h max) for approximately one month in total.</li> </ul> </li> </ul>"},{"location":"NSPS/technical-specifications.html#data-handling","title":"Data Handling","text":"<ul> <li>Event Storage: Retains event history for up to 3 months.</li> <li>Cache TTL: Default 5 seconds with configurable values.</li> <li>Data Consistency: Uses event timestamps to ensure chronological integrity during processing.</li> <li>Message Size Limit: Typical ESPF event is ~0.2KB; typical enriched event is ~1.5KB; in complex cases enriched data may reach up to 1MB.</li> </ul>"},{"location":"NSPS/technical-specifications.html#security-and-authentication","title":"Security and Authentication","text":"<ul> <li>Authentication Methods:<ul> <li>HTTP Basic Auth for inbound webhook events.</li> <li>Service account/identity-based authentication for inter-service communication.</li> <li>Token-based authentication for connector interfaces.</li> </ul> </li> <li>Access Control: Role-based access control for UI and management interfaces.</li> </ul>"},{"location":"NSPS/technical-specifications.html#reliability-and-fault-tolerance","title":"Reliability and Fault Tolerance","text":"<ul> <li>Availability: Built on cloud infrastructure with 99.9% availability SLA.</li> <li>Error Handling:<ul> <li>Automatic retries with exponential backoff.</li> <li>Long replay mechanism for persistently failing events (retries for up to one month with increasing intervals).</li> <li>Manual replay capability for persistent failures.</li> </ul> </li> <li>Maintenance Mode: Ability to pause event processing during maintenance windows.</li> <li>Monitoring: Real-time monitoring of queue depths, processing rates, and error counts.</li> </ul>"},{"location":"examples/python/simple-connector-fastapi/index.html","title":"NSPS Connector Example (Python/FastAPI)","text":"<p>About this project</p> <p>This is a minimal Python FastAPI service that listens for POST requests from NSPS containing enriched event data. It checks the Bearer token, extracts key fields (like event type and billing status), and prints them to the console. The project is intentionally simple and serves as a template for building or testing integrations with NSPS event flows.</p>"},{"location":"examples/python/simple-connector-fastapi/index.html#project-structure","title":"Project Structure","text":"<ul> <li><code>main.py</code> \u2014 application entry point</li> <li><code>requirements.txt</code> \u2014 dependencies</li> <li><code>.env.example</code> \u2014 example environment variables</li> <li><code>.env</code> \u2014 your actual environment variables (not committed)</li> <li><code>Dockerfile</code>, <code>docker-compose.yml</code> \u2014 containerization setup</li> <li><code>README.md</code> \u2014 this documentation</li> </ul>"},{"location":"examples/python/simple-connector-fastapi/index.html#environment-variables","title":"Environment Variables","text":"<p>Create a <code>.env</code> file in the project root with the following variables:</p> <pre><code>API_TOKEN=your-secret-token\nPORT=3000\n</code></pre> <ul> <li><code>API_TOKEN</code> \u2014 Bearer token required for authentication (must match the token sent in requests)</li> <li><code>PORT</code> \u2014 Port on which the server will listen (default: 3000)</li> </ul>"},{"location":"examples/python/simple-connector-fastapi/index.html#getting-started","title":"Getting Started","text":""},{"location":"examples/python/simple-connector-fastapi/index.html#local-run","title":"Local Run","text":"<ol> <li>(Optional) Create and activate a virtual environment:     <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\n</code></pre></li> <li>Install dependencies:     <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Copy <code>.env.example</code> to <code>.env</code> and set your token:     <pre><code>cp .env.example .env\n</code></pre></li> <li>Start the server:     <pre><code>python main.py\n</code></pre>     Or for development with hot-reload:     <pre><code>uvicorn main:app --reload --host 0.0.0.0 --port 3000\n</code></pre></li> </ol>"},{"location":"examples/python/simple-connector-fastapi/index.html#docker","title":"Docker","text":"<ol> <li>Build the image:     <pre><code>docker build -t nsps-connector .\n</code></pre></li> <li>Run the container:     <pre><code>docker run --env-file .env -p 3000:3000 nsps-connector\n</code></pre>     Or using docker-compose:     <pre><code>docker compose up --build\n</code></pre></li> </ol>"},{"location":"examples/python/simple-connector-fastapi/index.html#endpoints","title":"Endpoints","text":"<ul> <li><code>POST /process-event</code> \u2014 receives NSPS events, checks Bearer Token, logs <code>event_type</code> and <code>bill_status</code></li> </ul>"},{"location":"examples/python/simple-connector-fastapi/index.html#how-to-test","title":"How to Test","text":"<p>You can test the connector manually using curl:</p> <pre><code>curl -X POST http://localhost:3000/process-event \\\n  -H \"Authorization: Bearer your-secret-token\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"event_id\": \"3e84c79f-ab6f-4546-8e27-0b6ab866f1f5\",\n    \"data\": {\n      \"event_type\": \"SIM/Updated\",\n      \"variables\": {\n        \"i_env\": 1,\n        \"i_event\": 999999,\n        \"i_account\": 1,\n        \"curr_status\": \"used\",\n        \"prev_status\": \"active\"\n      }\n    },\n    \"pb_data\": {\n      \"account_info\": {\n        \"bill_status\": \"open\",\n        \"billing_model\": \"credit_account\",\n        \"blocked\": false,\n        \"i_account\": 1,\n        \"i_customer\": 6392,\n        \"i_product\": 3774,\n        \"id\": \"79123456789@msisdn\",\n        \"phone1\": \"\",\n        \"product_name\": \"wtl Pay as you go\",\n        \"time_zone_name\": \"Europe/Prague\",\n        \"assigned_addons\": [\n          {\n            \"addon_effective_from\": \"2025-05-16T12:59:46\",\n            \"addon_priority\": 10,\n            \"description\": \"\",\n            \"i_product\": 3775,\n            \"i_vd_plan\": 1591,\n            \"name\": \"wtl Youtube UHD\"\n          }\n        ],\n        \"service_features\": [\n          {\n            \"name\": \"netaccess_policy\",\n            \"effective_flag_value\": \"Y\",\n            \"attributes\": [\n              {\n                \"name\": \"access_policy\",\n                \"effective_value\": \"179\"\n              }\n            ]\n          }\n        ]\n      },\n      \"sim_info\": {\n        \"i_sim_card\": 3793,\n        \"imsi\": \"001010000020349\",\n        \"msisdn\": \"79123456789\",\n        \"status\": \"active\"\n      },\n      \"access_policy_info\": {\n        \"i_access_policy\": 179,\n        \"name\": \"WTL integration test\",\n        \"attributes\": [\n          {\n            \"group_name\": \"lte.wtl\",\n            \"name\": \"cs_profile\",\n            \"value\": \"cs-pp-20250319\"\n          },\n          {\n            \"group_name\": \"lte.wtl\",\n            \"name\": \"eps_profile\",\n            \"value\": \"eps-pp-20250319\"\n          }\n        ]\n      }\n    },\n    \"handler_id\": \"p1-nsps\",\n    \"created_at\": \"2025-03-12T16:47:30.443939+00:00\",\n    \"updated_at\": \"2025-03-12T16:47:36.585885+00:00\",\n    \"status\": \"received\"\n  }\n'\n</code></pre>"},{"location":"examples/python/simple-connector-fastapi/index.html#console-output-example","title":"Console Output Example","text":"<p>You will see something like this in the console:</p> <pre><code>Received event: SIM/Updated | bill status: open\n</code></pre>"},{"location":"examples/python/simple-connector-fastapi/index.html#example-of-successful-response","title":"Example of Successful Response","text":"<pre><code>{\n    \"message\": \"Event accepted for processing\"\n}\n</code></pre>"},{"location":"examples/python/simple-connector-fastapi/index.html#example-error-responses","title":"Example Error Responses","text":"<p>If the token is missing or invalid:</p> <pre><code>{\n    \"message\": \"Authentication failed\",\n    \"error\": \"Invalid API token\",\n    \"type\": \"AUTHENTICATION_ERROR\"\n}\n</code></pre> <p>If the request body is invalid or required fields are missing:</p> <pre><code>{\n    \"message\": \"Validation failed\",\n    \"error\": \"Validation failed\",\n    \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre>"},{"location":"examples/python/simple-connector-fastapi/overview.html","title":"Simple Connector (Python / FastAPI)","text":"<p>This example is a minimal NSPS connector implemented with FastAPI. It's intended as a starting point to show how to receive events from NSPS, verify the Bearer token, extract required fields from the request body, and return the expected responses.</p>"},{"location":"examples/python/simple-connector-fastapi/overview.html#what-this-project-is","title":"What this project is","text":"<ul> <li>A lightweight HTTP server that accepts POST requests from NSPS at <code>/process-event</code>.</li> <li>Demonstrates secure token-based verification (Authorization: Bearer ). <li>Shows simple validation of incoming event payload and how to read nested fields (for example <code>data.event_type</code> and <code>pb_data.account_info.bill_status</code>).</li> <li>Meant for local testing and as a template for building production connectors.</li>"},{"location":"examples/python/simple-connector-fastapi/overview.html#technologies-used","title":"Technologies used","text":"<ul> <li>Python 3.11+ (compatible with recent FastAPI/uvicorn releases)</li> <li>FastAPI for the web framework</li> <li>Uvicorn as ASGI server</li> <li>python-dotenv for loading environment variables from a <code>.env</code> file</li> </ul> <p>Dependencies (from <code>requirements.txt</code>):</p> <pre><code>fastapi==0.118.0\nuvicorn[standard]==0.37.0\npython-dotenv==1.1.1\n</code></pre>"},{"location":"examples/python/simple-connector-fastapi/overview.html#project-layout-key-files","title":"Project layout (key files)","text":"<ul> <li><code>main.py</code> \u2014 application entrypoint that defines the FastAPI app, token verification dependency, and <code>/process-event</code> route.</li> <li><code>.env.example</code> \u2014 example environment variables (API_TOKEN, PORT).</li> <li><code>requirements.txt</code> \u2014 pinned Python dependencies.</li> <li><code>Dockerfile</code>, <code>docker-compose.yml</code> \u2014 containerization files for running the example in Docker (optional).</li> </ul>"},{"location":"examples/python/simple-connector-fastapi/overview.html#code-explanation","title":"Code explanation","text":"<p>Token verification using FastAPI dependencies (HTTPBearer):</p> <pre><code>from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom fastapi import Depends, HTTPException, status\nimport os\n\nAPI_TOKEN = os.getenv(\"API_TOKEN\", \"your-secret-token\")\n\nbearer_scheme = HTTPBearer()\n\n\ndef verify_bearer_token(\n    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),\n):\n    token = credentials.credentials\n    if token != API_TOKEN:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail={\n                \"message\": \"Authentication failed\",\n                \"error\": \"Invalid API token\",\n                \"type\": \"AUTHENTICATION_ERROR\",\n            },\n        )\n</code></pre> <p>Processing the event payload and simple validation:</p> <pre><code>from fastapi import Request\nfrom fastapi.responses import JSONResponse\n\n@app.post(\"/process-event\")\nasync def process_event(\n    request: Request,\n    credentials: HTTPAuthorizationCredentials = Depends(verify_bearer_token),\n):\n    body = await request.json()\n    data = body.get(\"data\", {})\n    pb_data = body.get(\"pb_data\", {})\n    event_type = data.get(\"event_type\")\n    bill_status = pb_data.get(\"account_info\", {}).get(\"bill_status\")\n\n    if not event_type or not bill_status:\n        return JSONResponse(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            content={\n                \"message\": \"Validation failed\",\n                \"error\": \"Validation failed\",\n                \"type\": \"VALIDATION_ERROR\",\n            },\n        )\n\n    print(f\"Received event: {event_type} | bill status: {bill_status}\")\n\n    return JSONResponse(\n        status_code=status.HTTP_202_ACCEPTED,\n        content={\"message\": \"Event accepted for processing\"},\n    )\n</code></pre>"},{"location":"examples/python/simple-connector-fastapi/overview.html#how-to-run-locally","title":"How to run locally","text":"<ol> <li>Copy <code>.env.example</code> to <code>.env</code> and set <code>API_TOKEN</code> and <code>PORT</code>.</li> <li>Create a virtual environment and install requirements:</li> </ol> <pre><code>python -m venv .venv; .\\.venv\\Scripts\\Activate.ps1; pip install -r requirements.txt\n</code></pre> <ol> <li>Run with uvicorn:</li> </ol> <pre><code>uvicorn main:app --host 0.0.0.0 --port 3000 --reload\n</code></pre> <p>Or use the provided <code>Dockerfile</code> / <code>docker-compose.yml</code> for containerized runs.</p>"},{"location":"examples/python/simple-connector-fastapi/overview.html#notes","title":"Notes","text":"<ul> <li>This example is intentionally simple \u2014 extend it with structured logging, robust validation (Pydantic models), retries, persistence, or integration with other services as needed.</li> <li>Ensure the <code>API_TOKEN</code> used by NSPS Handler matches your connector's token.</li> </ul> <p>Also see README file</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html","title":"WTL HLR/HSS Connector Microservice","text":"<p>FastAPI microservice that processes PortaBilling ESPF events (already processed by NSPS) and synchronizes subscriber data with WTL HLR/HSS system.</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#features","title":"Features","text":"<ul> <li>FastAPI web framework</li> <li>Processes PortaBilling ESPF events that have been pre-processed by NSPS</li> <li>Synchronizes subscriber data with WTL HLR/HSS system</li> <li>Docker containerization</li> <li>Health check endpoint</li> <li>JSON structured logging with request tracing</li> <li>Configuration via environment variables</li> <li>Bearer token authentication</li> </ul>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#api-endpoints","title":"API Endpoints","text":""},{"location":"examples/python/wtl-hlr-hss-connector/index.html#health-check","title":"Health Check","text":"<ul> <li>GET <code>/health</code> - Service health status</li> </ul>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#event-processing","title":"Event Processing","text":"<ul> <li>POST <code>/process-event</code> - Process PortaBilling ESPF events (post-NSPS processing)</li> <li>Requires Bearer authentication</li> <li>Accepts JSON payload with event data</li> </ul>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#installation-and-setup","title":"Installation and Setup","text":""},{"location":"examples/python/wtl-hlr-hss-connector/index.html#using-docker-compose-recommended","title":"Using Docker Compose (Recommended)","text":"<ol> <li> <p>Configure:    <pre><code>cd wtl-hlr-hss-microservice\ncp .env.example .env\n# Edit .env file with your configuration\n</code></pre></p> </li> <li> <p>Build and run:    <pre><code>docker compose up --build\n</code></pre></p> </li> <li> <p>Check the service:    <pre><code>curl http://localhost:8000/health\n</code></pre></p> </li> </ol>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#using-docker","title":"Using Docker","text":"<ol> <li> <p>Build the image:    <pre><code>docker build -t wtl-hlr-hss-connector .\n</code></pre></p> </li> <li> <p>Run the container:    <pre><code>docker run -p 8000:8000 \\\n  -e API_TOKEN=your-token \\\n  -e WTL_API_URL=http://your-wtl-url \\\n  -e WTL_API_TOKEN=your-wtl-token \\\n  wtl-hlr-hss-connector\n</code></pre></p> </li> </ol>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#local-development","title":"Local Development","text":"<ol> <li> <p>Install dependencies:    <pre><code>pip install -r app/requirements.txt\n</code></pre></p> </li> <li> <p>Set environment variables:    <pre><code>export API_TOKEN=your-token\nexport WTL_API_URL=http://your-wtl-url\nexport WTL_API_TOKEN=your-wtl-token\n# ... other variables\n</code></pre></p> </li> <li> <p>Run the application:    <pre><code>uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload\n</code></pre></p> </li> </ol>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#environment-variables","title":"Environment Variables","text":""},{"location":"examples/python/wtl-hlr-hss-connector/index.html#required-variables","title":"Required Variables","text":"Variable Description Example <code>API_TOKEN</code> Bearer token for API authentication <code>your-secure-token</code> <code>WTL_API_URL</code> WTL API base URL <code>http://wtl-api:3001/wtl/hlr/v1</code> <code>WTL_API_TOKEN</code> WTL API authentication token <code>wtl-token</code>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#optional-variables","title":"Optional Variables","text":"Variable Description Default <code>APP_NAME</code> Application name <code>wtl-hlr-hss-connector</code> <code>LOG_LEVEL</code> Logging level (DEBUG, INFO, WARNING, ERROR) <code>INFO</code> <code>DEBUG</code> Enable debug mode <code>false</code> <code>WTL_DEFAULT_CS_PROFILE</code> Default CS profile <code>default</code> <code>WTL_DEFAULT_EPS_PROFILE</code> Default EPS profile <code>default</code> <code>WTL_HTTP_REQUESTS_TIMEOUT</code> HTTP timeout for WTL requests <code>30.0</code> <code>WTL_IMSI_REGEXP</code> IMSI validation regex <code>None</code> <p>Note: When deploying to Google Cloud Run, the <code>PORT</code> environment variable is automatically managed by the platform and should not be set manually.</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#usage-example","title":"Usage Example","text":""},{"location":"examples/python/wtl-hlr-hss-connector/index.html#process-event-request","title":"Process Event Request","text":"<pre><code>curl -X POST http://localhost:8000/process-event \\\n  -H \"Authorization: Bearer your-api-token\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"event_id\": \"3e84c79f-ab6f-4546-8e27-0b6ab866f1fb\",\n    \"data\": {\n      \"event_type\": \"SIM/Updated\",\n      \"variables\": {\n        \"i_env\": 1,\n        \"i_event\": 999999,\n        \"i_account\": 1,\n        \"curr_status\": \"used\",\n        \"prev_status\": \"active\"\n      }\n    },\n    \"pb_data\": {\n      \"account_info\": {\n        \"bill_status\": \"open\",\n        \"billing_model\": \"credit_account\",\n        \"blocked\": false,\n        \"i_account\": 1,\n        \"i_customer\": 6392,\n        \"i_product\": 3774,\n        \"id\": \"79123456789@msisdn\",\n        \"phone1\": \"\",\n        \"product_name\": \"wtl Pay as you go\",\n        \"time_zone_name\": \"Europe/Prague\",\n        \"assigned_addons\": [\n          {\n            \"addon_effective_from\": \"2025-05-16T12:59:46\",\n            \"addon_priority\": 10,\n            \"description\": \"\",\n            \"i_product\": 3775,\n            \"i_vd_plan\": 1591,\n            \"name\": \"wtl Youtube UHD\"\n          }\n        ],\n        \"service_features\": [\n          {\n            \"name\": \"netaccess_policy\",\n            \"effective_flag_value\": \"Y\",\n            \"attributes\": [\n              {\n                \"name\": \"access_policy\",\n                \"effective_value\": \"179\"\n              }\n            ]\n          }\n        ]\n      },\n      \"sim_info\": {\n        \"i_sim_card\": 3793,\n        \"imsi\": \"001010000020349\",\n        \"msisdn\": \"79123456789\",\n        \"status\": \"active\"\n      },\n      \"access_policy_info\": {\n        \"i_access_policy\": 179,\n        \"name\": \"WTL integration test\",\n        \"attributes\": [\n          {\n            \"group_name\": \"lte.wtl\",\n            \"name\": \"cs_profile\",\n            \"value\": \"cs-pp-20250319\"\n          },\n          {\n            \"group_name\": \"lte.wtl\",\n            \"name\": \"eps_profile\",\n            \"value\": \"eps-pp-20250319\"\n          }\n        ]\n      }\n    },\n    \"handler_id\": \"p1-nsps\",\n    \"created_at\": \"2025-03-12T16:47:30.443939+00:00\",\n    \"updated_at\": \"2025-03-12T16:47:36.585885+00:00\",\n    \"status\": \"received\"\n  }'\n</code></pre>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#response-examples","title":"Response Examples","text":""},{"location":"examples/python/wtl-hlr-hss-connector/index.html#successful-event-processing","title":"Successful Event Processing","text":"<pre><code>{\n  \"message\": \"Event processed successfully\"\n}\n</code></pre>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#event-ignored-no-action","title":"Event Ignored (No Action)","text":"<pre><code>{\n  \"message\": \"Event ignored: No defined action for event type: SIM/Updated\"\n}\n</code></pre>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#event-ignored-invalid-imsi","title":"Event Ignored (Invalid IMSI)","text":"<pre><code>{\n  \"message\": \"Event ignored: IMSI is empty or not provided\"\n}\n</code></pre>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#event-ignored-imsi-validation-failed","title":"Event Ignored (IMSI Validation Failed)","text":"<pre><code>{\n  \"message\": \"Event ignored: IMSI 901700000050170 doesn't follow the regexp provided\"\n}\n</code></pre>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#error-response","title":"Error Response","text":"<pre><code>{\n  \"message\": \"Internal server error\",\n  \"error\": \"Error details...\"\n}\n</code></pre>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#monitoring-and-logging","title":"Monitoring and Logging","text":"<ul> <li>Health checks available at <code>/health</code></li> <li>JSON formatted logs (when not in debug mode)</li> <li>Request tracing with <code>x-b3-traceid</code> and <code>x-request-id</code> headers</li> </ul>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#architecture","title":"Architecture","text":"<pre><code>app/\n\u251c\u2500\u2500 main.py              # FastAPI application and routes\n\u251c\u2500\u2500 core/                # Configuration and utilities\n\u2502   \u251c\u2500\u2500 config.py        # Settings and configuration\n\u2502   \u251c\u2500\u2500 logging.py       # Logging setup\n\u2502   \u251c\u2500\u2500 event_processor.py # Event processing utilities\n\u2502   \u2514\u2500\u2500 middleware.py    # Custom middlewares\n\u251c\u2500\u2500 models/              # Data models\n\u2502   \u251c\u2500\u2500 errors.py        # Error response models\n\u2502   \u251c\u2500\u2500 events.py        # PortaBilling event models\n\u2502   \u2514\u2500\u2500 wtl.py           # WTL API models\n\u251c\u2500\u2500 services/            # Business logic\n\u2502   \u251c\u2500\u2500 pb_event.py      # PortaBilling event processor\n\u2502   \u2514\u2500\u2500 wtl_client.py    # WTL API client\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#deployment","title":"Deployment","text":"<p>This microservice supports deployment to multiple cloud platforms. Each platform has its own dedicated deployment scripts and configuration.</p> <p>Other platforms can also be used for deployment, but currently there are no deployment scripts provided for them.</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#supported-cloud-platforms","title":"Supported Cloud Platforms","text":"Platform Service Status Scripts Location Google Cloud Platform Cloud Run \u2705 Implemented <code>_gcp-deploy/</code> Amazon Web Services App Runner \u2705 Implemented <code>_aws-deploy/</code>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#google-cloud-platform-gcp-deployment","title":"Google Cloud Platform (GCP) Deployment","text":"<p>The microservice can be deployed to Google Cloud Run using the provided GCP deployment scripts located in <code>_gcp-deploy/</code> directory.</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Google Cloud CLI installed and configured</li> <li>Docker installed (for Cloud Run deployment)</li> <li>Authenticated with Google Cloud (<code>gcloud auth login</code>)</li> </ul>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#quick-commands","title":"Quick Commands","text":"<p>For Cloud Run: <pre><code># Interactive deployment (recommended)\nmake gcp-deploy\n\n# Force full redeploy\nmake gcp-deploy-force\n\n# Update environment variables only (fast)\nmake gcp-update-env\n\n# View service logs\nmake gcp-logs\n\n# Check service status\nmake gcp-status\n</code></pre></p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#environment-configuration","title":"Environment Configuration","text":"<ol> <li> <p>Set GCP deployment variables:    <pre><code>export PROJECT_ID=your-project-id    # Your GCP Project ID\nexport REGION=europe-west3           # Optional, defaults to europe-west3\n</code></pre></p> </li> <li> <p>Create .env file:    <pre><code>cp .env.example .env\n# Edit .env with your configuration\n</code></pre></p> </li> <li> <p>Required variables in .env:    <pre><code>API_TOKEN=your-secure-api-token\nWTL_API_URL=https://wtl-api.example.com/wtl/hlr/v1\nWTL_API_TOKEN=your-wtl-api-token\n</code></pre></p> </li> </ol> <p>The deployment scripts will automatically load variables from <code>.env</code> file and configure the service.</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#how-it-works","title":"How It Works","text":"<p>The deployment scripts: - \u2705 Automatically load configuration from <code>.env</code> file - \u2705 Check prerequisites and environment variables - \u2705 Configure gcloud settings and enable required APIs - \u2705 Deploy service with environment variables - \u2705 Test the deployment - \u2705 Provide interactive options for existing services</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#service-configuration","title":"Service Configuration","text":"<p>Cloud Run configuration: - Memory: 512Mi - CPU: 1 vCPU - Min instances: 0 (scales to zero) - Max instances: 10 - Timeout: 300 seconds - Port: Automatically managed by Cloud Run - Public access: Enabled</p> <p>To modify these settings, edit the configuration in the deployment script: - Cloud Run: <code>_gcp-deploy/deploy_cloud_run_service.sh</code></p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#amazon-web-services-aws-deployment","title":"Amazon Web Services (AWS) Deployment","text":"<p>The microservice can be deployed to AWS App Runner using the provided AWS deployment scripts located in <code>_aws-deploy/</code> directory.</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#prerequisites_1","title":"Prerequisites","text":"<ul> <li>AWS CLI installed and configured</li> <li>Docker installed</li> <li>AWS account with appropriate permissions</li> </ul>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#quick-commands_1","title":"Quick Commands","text":"<pre><code># Deploy or update service\nmake aws-deploy\n\n# Test existing service only\nmake aws-test-only\n\n# Delete service\nmake aws-destroy\n</code></pre>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#environment-configuration_1","title":"Environment Configuration","text":"<ol> <li> <p>Configure AWS CLI:    <pre><code>aws configure\n</code></pre></p> </li> <li> <p>Set AWS deployment variables:    <pre><code>export AWS_ACCOUNT_ID=123456789012  # Your AWS Account ID\nexport AWS_REGION=eu-west-1         # Optional, defaults to eu-west-1\n</code></pre></p> </li> <li> <p>Create .env file:    <pre><code>cp .env.example .env\n# Edit .env with your configuration\n</code></pre></p> </li> <li> <p>Required variables in .env:    <pre><code>API_TOKEN=your-secure-api-token\nWTL_API_URL=https://wtl-api.example.com/wtl/hlr/v1\nWTL_API_TOKEN=your-wtl-api-token\n</code></pre></p> </li> </ol> <p>The deployment script will automatically load variables from <code>.env</code> file and configure the service.</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#how-it-works_1","title":"How It Works","text":"<p>The deployment script: - \u2705 Automatically loads configuration from <code>.env</code> file - \u2705 Checks prerequisites and AWS authentication - \u2705 Creates ECR repository with security scanning - \u2705 Builds and pushes Docker image to ECR - \u2705 Creates IAM roles for App Runner ECR access - \u2705 Deploys service with auto scaling configuration - \u2705 Tests the deployment with health checks - \u2705 Provides options for testing and service management</p>"},{"location":"examples/python/wtl-hlr-hss-connector/index.html#service-configuration_1","title":"Service Configuration","text":"<p>The deployment configures App Runner with: - Memory: 0.5 GB - CPU: 0.25 vCPU - Min instances: 0 (scale-to-zero) \u26a1 - Max instances: 3 - Concurrency: 100 requests per instance - Port: 8000 (automatically detected) - Public access: Enabled with HTTPS</p> <p>To modify these settings, edit the configuration variables at the beginning of <code>_aws-deploy/deploy_apprunner.sh</code>.</p>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html","title":"Overview","text":"<p>This guide explains an example of building an NSPS connector in Python using FastAPI. The connector receives events from NSPS, validates and processes the payload, and then forwards the enriched data to an external system (in this example \u2014 Google Sheets). It also demonstrates how to implement Bearer token authentication and how to construct proper responses for NSPS, ensuring events are handled correctly.</p> <p>You can find the full example repository here: WTL HLR-HSS Connector</p>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#workflow","title":"Workflow","text":"<ol> <li>Accept HTTP request to <code>POST /process-event</code> with Bearer auth.</li> <li>Set request context (trace IDs) and JSON logging via middleware.</li> <li>Validate payload against the <code>Event</code> schema (includes <code>data</code> and optional <code>pb_data</code>).</li> <li>Determine provisioning action from <code>event_type</code>.</li> <li>Extract required identifiers and attributes from <code>pb_data</code>:<ul> <li>IMSI (required), MSISDN (from <code>account_info.id</code> when <code>bill_status == open</code>)</li> <li>Subscriber status derived from <code>blocked</code> and <code>bill_status</code></li> <li>Profiles (<code>cs_profile</code>, <code>eps_profile</code>) from access policy or defaults</li> <li>Optional IMSI regex validation</li> </ul> </li> <li>Build a unified request for the WTL API.</li> <li>Call the external WTL API with retry-safe HTTP client and map errors to typed responses.</li> <li>Return 202 on success (accepted/processed) or a standardized JSON error.</li> </ol>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#connector-flow-explained","title":"Connector Flow Explained","text":""},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#1-accept-request","title":"1. Accept request","text":"<p>The microservice exposes a single POST endpoint at <code>/process-event</code> using FastAPI. This endpoint is designed to be minimal, delegating all business logic to a processor function. The endpoint expects a JSON payload matching the <code>Event</code> schema and is protected by authentication (see next step). The handler simply receives the validated event data and passes it to the event processor, which orchestrates the rest of the workflow.</p> app/main.py<pre><code>app = FastAPI(\n    title=\"HLR/HSS Connector Microservice\",\n    description=\"Processes PortaBilling ESPF events (post-NSPS) and syncs with HLR/HSS Core system\",\n    version=\"1.0.0\",\n)\n</code></pre> app/main.py<pre><code>@app.post(\n    \"/process-event\",\n    dependencies=[Depends(verify_token)],\n    response_model=EventResponse,\n    status_code=status.HTTP_202_ACCEPTED,\n)\nasync def process_event(event_data: Event):\n    return event_processor.process_event(event_data)\n</code></pre> <p>View source: <code>app/main.py</code></p>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#2-enforce-bearer-auth","title":"2. Enforce Bearer auth","text":"<p>Authentication is handled by a dependency (<code>Depends(verify_token)</code>) that checks for a valid Bearer token in the request. The <code>verify_token</code> function compares the provided token to a value stored in environment variables. If the token is missing or incorrect, the function raises an HTTP 401 error with a standard <code>WWW-Authenticate: Bearer</code> header, ensuring clients know how to authenticate. This approach centralizes security logic, making it easy to update or reuse across endpoints.</p> app/main.py<pre><code>security = HTTPBearer()\n</code></pre> app/main.py<pre><code>def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    if credentials.credentials != settings.API_TOKEN:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid access token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    return credentials.credentials\n</code></pre> <p>View source: <code>app/main.py</code></p> <ul> <li>Why Bearer here: NSPS authenticates with a shared secret; rotating the token only requires changing env vars.</li> <li>Failure behavior: 401 is returned with <code>WWW-Authenticate: Bearer</code>, which is standard for API clients.</li> </ul>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#3-set-request-context-and-json-logging","title":"3. Set request context and JSON logging","text":"<p>Before processing each request, middleware sets up tracing context by extracting or generating unique request IDs from headers. This ensures every request is traceable in logs, even if the client does not provide tracing headers. The middleware attaches these IDs to the request context and logs the completion of each HTTP request in structured JSON format, including status codes and timestamps. This makes debugging and monitoring much easier, especially in distributed or cloud environments.</p> app/core/middleware.py<pre><code>def set_request_context(request: Request):\n    REQUEST_ID_VAR.set(request.headers.get(REQUEST_ID_HEADER, uuid.uuid4().hex[:16]))\n    UNIQUE_ID_VAR.set(request.headers.get(UNIQUE_ID_HEADER, uuid.uuid4().hex[:16]))\n</code></pre> app/core/middleware.py<pre><code>async def request_context_middleware(request: Request, call_next):\n    set_request_context(request)\n    response = await call_next(request)\n    logger.info(\n        \"HTTP request completed\",\n        extra={\"status_code\": response.status_code},\n    )\n    return response\n</code></pre> <p>View source: <code>app/core/middleware.py</code></p> <ul> <li>Log shape: JSON via structlog with automatic timestamp and traced IDs.</li> </ul>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#4-validate-payload-against-schemas","title":"4. Validate payload against schemas","text":"<p>Incoming requests are validated against Pydantic models before any business logic runs. The <code>Event</code> model requires an <code>event_id</code>, a nested <code>data</code> object (with <code>event_type</code> and <code>variables</code>), and optionally a <code>pb_data</code> object. If any required fields are missing or malformed, FastAPI automatically returns a 422 error, making it clear to clients what is wrong with their request. This strict validation ensures that only well-formed data reaches the business logic, reducing the risk of runtime errors.</p> app/models/events.py<pre><code>class Event(BaseModel):\n    event_id: str = Field(\n        description=\"Unique identifier of the event\",\n        examples=[\"a3623086-24c2-47fb-a17f-929d9e542ed2\"]\n    )\n    data: ESPFEvent = Field(\n        description=\"Event data containing type and variables\"\n    )\n    pb_data: Optional[PBData] = Field(\n        None,\n        description=\"Simplified PortaBilling data with only essential fields\"\n    )\n</code></pre> app/models/events.py<pre><code>class ESPFEvent(BaseModel):\n    event_type: str = Field(\n        description=\"The type of the event\",\n        examples=[\"SIM/Updated\"]\n    )\n    variables: Dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"All event variables passed as-is from original event\",\n    )\n</code></pre> <p>View source: <code>app/models/events.py</code></p>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#5-map-event_type-wtl-action","title":"5. Map event_type \u2192 WTL action","text":"<p>The connector uses a mapping to translate incoming event types (such as <code>SIM/Updated</code>) into specific provisioning actions for the WTL system (like <code>update</code>). This mapping is explicit and easy to extend, making it clear which event types are supported. If an unknown event type is received, the system logs the event and returns a 202 response, ensuring that unsupported events do not break the NSPS pipeline. This design makes the connector robust and easy to maintain.</p> app/models/wtl.py<pre><code>class WTLProvAction(str, Enum):\n    INSERT = \"insert\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\n    SET = \"set\"\n    UNSET = \"unset\"\n    MODIFY = \"modify\"\n</code></pre> app/models/wtl.py<pre><code>EVENT_ACTION_MAP = {\n    EventType.SIM_UPDATED: WTLProvAction.UPDATE,\n}\n</code></pre> app/models/wtl.py<pre><code>class EventWTLActionMapper(BaseModel):\n    event_type: str\n\n    @property\n    def action(self) -&gt; str:\n        return EVENT_ACTION_MAP.get(self.event_type)\n</code></pre> <p>View source: <code>app/models/wtl.py</code></p>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#6-extract-and-derive-identifiers-and-attributes","title":"6. Extract and derive identifiers and attributes","text":"<p>The connector extracts all required identifiers and attributes from the incoming event and its nested data. Helper methods in <code>pb_event.py</code> handle extraction of IMSI, MSISDN, account ID, billing status, block status, and profiles. These methods encapsulate logic for handling missing fields, applying defaults, and validating values (such as IMSI format via regex). This separation makes the code easier to test and adapt to changes in the event schema, and ensures that all required data is available before building the WTL request.</p> app/services/pb_event.py<pre><code>def get_imsi_from_sim_info(self) -&gt; str:\n    return self.sim_info and self.sim_info.imsi\n</code></pre> app/services/pb_event.py<pre><code>def get_account_id(self) -&gt; Optional[str]:\n    if not self.account_info:\n        return None\n    account_id = self.account_info.id\n    return account_id.split(\"@msisdn\")[0] if \"@msisdn\" in account_id else None\n</code></pre> app/services/pb_event.py<pre><code>def get_bill_status(self) -&gt; Optional[BillStatus]:\n    return self.account_info and self.account_info.bill_status\n</code></pre> app/services/pb_event.py<pre><code>def get_block_status(self) -&gt; Optional[bool]:\n    return self.account_info and self.account_info.blocked\n</code></pre> app/services/pb_event.py<pre><code>def get_cs_profile(self) -&gt; str:\n    return self._get_profile(\"cs_profile\", settings.WTL_DEFAULT_CS_PROFILE)\n</code></pre> app/services/pb_event.py<pre><code>def validate_imsi_using_regex(self, imsi: str) -&gt; bool:\n    if settings.WTL_IMSI_REGEXP and not re.search(settings.WTL_IMSI_REGEXP, imsi):\n        return False\n    return True\n</code></pre> <p>View source: <code>app/services/pb_event.py</code></p> app/core/event_processor.py<pre><code>subscriber_status = SubscriberStatus.OPERATOR_DETERMINED_BARRING.value\nif (\n    not processor.get_block_status()\n    and processor.get_bill_status() == BillStatus.OPEN.value\n):\n    subscriber_status = SubscriberStatus.SERVICE_GRANTED.value\n</code></pre> <p>View source: <code>app/core/event_processor.py</code></p>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#7-build-the-unified-wtl-request","title":"7. Build the unified WTL request","text":"<p>Once all required data is extracted and derived, the connector constructs a <code>UnifiedSyncRequest</code> object. This object aggregates all the necessary fields\u2014IMSI, subscriber status, MSISDN list, CS and EPS profiles, and the action to perform. The use of Pydantic models ensures that the request is strictly validated before being sent, reducing the risk of malformed requests reaching the WTL API. This step keeps the business logic clean and focused on data transformation.</p> app/core/event_processor.py<pre><code>request_data = UnifiedSyncRequest(\n    imsi=imsi,\n    subscriber_status=subscriber_status,\n    msisdn=msisdn_list,\n    cs_profile=processor.get_cs_profile(),\n    eps_profile=processor.get_eps_profile(),\n    action=action,\n)\n</code></pre> <p>View source: <code>app/core/event_processor.py</code></p>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#8-call-wtl-api-and-map-errors","title":"8. Call WTL API and map errors","text":"<p>The connector sends the unified request to the WTL API using an HTTP client with a configurable timeout and custom headers. The response is parsed and validated against a response model. If the WTL API indicates a failure, the connector raises a domain-specific exception, which is then mapped to an appropriate HTTP error code for the client. This separation of concerns ensures that transport errors and business errors are handled cleanly and consistently.</p> app/services/wtl_client.py<pre><code>with httpx.Client(\n    timeout=settings.WTL_HTTP_REQUESTS_TIMEOUT,\n    headers=self.headers,\n) as client:\n    response = client.post(url, json=request.model_dump(exclude_none=True))\n    response.raise_for_status()\n\n    wtl_response = WTLResponse.model_validate(response.json())\n\n    if not wtl_response.is_successful:\n        raise WTLServiceError(\n            message=\"WTL service error\",\n            error=wtl_response.error or \"Unknown error\",\n        )\n</code></pre> <p>View source: <code>app/services/wtl_client.py</code></p>"},{"location":"examples/python/wtl-hlr-hss-connector/overview.html#9-return-response","title":"9. Return response","text":"<p>After successful processing, the endpoint returns a JSON response with a 202 Accepted status. This signals to NSPS that the event was received and processed (or queued) successfully, allowing the pipeline to continue without waiting for downstream systems. If any error occurs, the connector returns a standardized error response with the appropriate HTTP status code, making it easy for clients to handle failures.</p> app/core/event_processor.py<pre><code>return JSONResponse(\n    content={\"message\": \"Event processed successfully\"},\n    status_code=status.HTTP_202_ACCEPTED\n)\n</code></pre> <p>View source: <code>app/core/event_processor.py</code></p>"},{"location":"examples/typescript/simple-connector-express/index.html","title":"NSPS Connector Example (TypeScript/Express)","text":"<p>About this project</p> <p>This is a minimal Node.js (Express) service that listens for POST requests from NSPS containing enriched event data. It checks the Bearer token, extracts key fields (like event type and billing status), and prints them to the console. The project is intentionally simple and serves as a template for building or testing integrations with NSPS event flows.</p>"},{"location":"examples/typescript/simple-connector-express/index.html#project-structure","title":"Project Structure","text":"<ul> <li><code>src/</code> \u2014 main TypeScript source code<ul> <li><code>index.ts</code> \u2014 application entry point</li> </ul> </li> <li><code>dist/</code> \u2014 compiled JavaScript output (after build)</li> <li><code>.env.example</code> \u2014 example environment variables</li> <li><code>.env</code> \u2014 your actual environment variables (not committed)</li> <li><code>package.json</code> \u2014 dependencies and scripts</li> <li><code>tsconfig.json</code> \u2014 TypeScript configuration</li> <li><code>Dockerfile</code>, <code>docker-compose.yaml</code> \u2014 containerization setup</li> <li><code>README.md</code> \u2014 this documentation</li> </ul>"},{"location":"examples/typescript/simple-connector-express/index.html#environment-variables","title":"Environment Variables","text":"<p>Create a <code>.env</code> file in the project root with the following variables:</p> <pre><code>API_TOKEN=your-secret-token\nPORT=3000\n</code></pre> <ul> <li><code>API_TOKEN</code> \u2014 Bearer token required for authentication (must match the token sent in requests)</li> <li><code>PORT</code> \u2014 Port on which the server will listen (default: 3000)</li> </ul>"},{"location":"examples/typescript/simple-connector-express/index.html#getting-started","title":"Getting Started","text":""},{"location":"examples/typescript/simple-connector-express/index.html#local-run","title":"Local Run","text":"<ol> <li>Copy <code>.env.example</code> to <code>.env</code> and set your token:     <pre><code>cp .env.example .env\n</code></pre></li> <li>Install dependencies:     <pre><code>npm install\n</code></pre></li> <li>Build TypeScript:     <pre><code>npm run build\n</code></pre></li> <li>Start the server:     <pre><code>npm start\n</code></pre>     Or for development with hot-reload:     <pre><code>npm run dev\n</code></pre></li> </ol>"},{"location":"examples/typescript/simple-connector-express/index.html#docker","title":"Docker","text":"<ol> <li>Build the image:     <pre><code>docker build -t nsps-connector .\n</code></pre></li> <li>Run the container:     <pre><code>docker run --env-file .env -p 3000:3000 nsps-connector\n</code></pre>     Or using docker-compose:     <pre><code>docker-compose up --build\n</code></pre></li> </ol>"},{"location":"examples/typescript/simple-connector-express/index.html#endpoints","title":"Endpoints","text":"<ul> <li><code>POST /process-event</code> \u2014 receives NSPS events, checks Bearer Token, logs <code>event_type</code> and <code>bill_status</code></li> </ul>"},{"location":"examples/typescript/simple-connector-express/index.html#how-to-test","title":"How to Test","text":"<p>You can test the connector manually using curl:</p> <pre><code>curl -X POST http://localhost:3000/process-event \\\n  -H \"Authorization: Bearer your-secret-token\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"event_id\": \"3e84c79f-ab6f-4546-8e27-0b6ab866f1f5\",\n    \"data\": {\n      \"event_type\": \"SIM/Updated\",\n      \"variables\": {\n        \"i_env\": 1,\n        \"i_event\": 999999,\n        \"i_account\": 1,\n        \"curr_status\": \"used\",\n        \"prev_status\": \"active\"\n      }\n    },\n    \"pb_data\": {\n      \"account_info\": {\n        \"bill_status\": \"open\",\n        \"billing_model\": \"credit_account\",\n        \"blocked\": false,\n        \"i_account\": 1,\n        \"i_customer\": 6392,\n        \"i_product\": 3774,\n        \"id\": \"79123456789@msisdn\",\n        \"phone1\": \"\",\n        \"product_name\": \"wtl Pay as you go\",\n        \"time_zone_name\": \"Europe/Prague\",\n        \"assigned_addons\": [\n          {\n            \"addon_effective_from\": \"2025-05-16T12:59:46\",\n            \"addon_priority\": 10,\n            \"description\": \"\",\n            \"i_product\": 3775,\n            \"i_vd_plan\": 1591,\n            \"name\": \"wtl Youtube UHD\"\n          }\n        ],\n        \"service_features\": [\n          {\n            \"name\": \"netaccess_policy\",\n            \"effective_flag_value\": \"Y\",\n            \"attributes\": [\n              {\n                \"name\": \"access_policy\",\n                \"effective_value\": \"179\"\n              }\n            ]\n          }\n        ]\n      },\n      \"sim_info\": {\n        \"i_sim_card\": 3793,\n        \"imsi\": \"001010000020349\",\n        \"msisdn\": \"79123456789\",\n        \"status\": \"active\"\n      },\n      \"access_policy_info\": {\n        \"i_access_policy\": 179,\n        \"name\": \"WTL integration test\",\n        \"attributes\": [\n          {\n            \"group_name\": \"lte.wtl\",\n            \"name\": \"cs_profile\",\n            \"value\": \"cs-pp-20250319\"\n          },\n          {\n            \"group_name\": \"lte.wtl\",\n            \"name\": \"eps_profile\",\n            \"value\": \"eps-pp-20250319\"\n          }\n        ]\n      }\n    },\n    \"handler_id\": \"p1-nsps\",\n    \"created_at\": \"2025-03-12T16:47:30.443939+00:00\",\n    \"updated_at\": \"2025-03-12T16:47:36.585885+00:00\",\n    \"status\": \"received\"\n  }\n'\n</code></pre>"},{"location":"examples/typescript/simple-connector-express/index.html#console-output-example","title":"Console Output Example","text":"<p>You will see something like this in the console:</p> <pre><code>Received event: SIM/Updated | bill status: open\n</code></pre>"},{"location":"examples/typescript/simple-connector-express/index.html#example-of-successful-response","title":"Example of Successful Response","text":"<pre><code>{\n    \"message\": \"Event accepted for processing.\"\n}\n</code></pre>"},{"location":"examples/typescript/simple-connector-express/index.html#example-error-responses","title":"Example Error Responses","text":"<p>If the token is missing or invalid:</p> <pre><code>{\n    \"message\": \"Authentication failed\",\n    \"error\": \"Invalid API token\",\n    \"type\": \"AUTHENTICATION_ERROR\"\n}\n</code></pre> <p>If the request body is invalid or required fields are missing:</p> <pre><code>{\n    \"message\": \"Validation failed\",\n    \"error\": \"Validation failed\",\n    \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre>"},{"location":"examples/typescript/simple-connector-express/overview.html","title":"Simple Connector (TypeScript / Express)","text":"<p>This example shows a minimal NSPS connector implemented with Express and TypeScript. It demonstrates how to receive POST events from NSPS at <code>/process-event</code>, verify the Bearer token, validate incoming payload fields, and return responses expected by NSPS.</p>"},{"location":"examples/typescript/simple-connector-express/overview.html#what-this-project-is","title":"What this project is","text":"<ul> <li>A small Express server written in TypeScript that accepts NSPS event requests.</li> <li>Demonstrates middleware-based token verification and request body parsing.</li> <li>Shows simple validation of incoming event payload and how to read nested fields (for example <code>data.event_type</code> and <code>pb_data.account_info.bill_status</code>).</li> <li>Intended as a quick-start template for building production-ready connectors.</li> </ul>"},{"location":"examples/typescript/simple-connector-express/overview.html#technologies-used","title":"Technologies used","text":"<ul> <li>Node.js (16+ recommended)</li> <li>TypeScript for type safety</li> <li>Express for the web framework</li> <li>dotenv for environment variable loading</li> </ul> <p>Dependencies (from <code>package.json</code>):</p> <pre><code>\"dependencies\": {\n    \"dotenv\": \"^17.2.3\",\n    \"express\": \"^5.1.0\"\n},\n\"devDependencies\": {\n    \"@types/express\": \"^5.0.3\",\n    \"@types/node\": \"^24.6.2\",\n    \"nodemon\": \"^3.1.10\",\n    \"typescript\": \"^5.9.3\"\n}\n</code></pre>"},{"location":"examples/typescript/simple-connector-express/overview.html#project-layout-key-files","title":"Project layout (key files)","text":"<ul> <li><code>src/index.ts</code> \u2014 main application file: config loading, Express app setup, token verification middleware, and <code>/process-event</code> route.</li> <li><code>.env.example</code> \u2014 example environment variables (API_TOKEN, PORT).</li> <li><code>package.json</code>, <code>tsconfig.json</code> \u2014 project metadata and TypeScript configuration.</li> <li><code>Dockerfile</code>, <code>docker-compose.yaml</code> \u2014 containerization files for running the example in Docker (optional).</li> <li><code>README.md</code> \u2014 example README with usage and additional notes. See <code>README.md</code> in this folder for quick start and examples.</li> </ul>"},{"location":"examples/typescript/simple-connector-express/overview.html#code-explanation","title":"Code explanation","text":"<p>Bearer token verification middleware:</p> <pre><code>import type { Request, Response, NextFunction } from 'express';\n\nconst API_TOKEN = process.env.API_TOKEN || 'your-secret-token';\n\nfunction verifyBearerToken(req: Request, res: Response, next: NextFunction) {\n    const auth = req.headers['authorization'] || '';\n    const token = auth.toString().replace('Bearer ', '');\n    if (!auth.toString().startsWith('Bearer ') || token !== API_TOKEN) {\n        return res.status(401).json({\n            message: 'Authentication failed',\n            error: 'Invalid API token',\n            type: 'AUTHENTICATION_ERROR',\n        });\n    }\n    next();\n}\n</code></pre> <p>Processing the event and validating required fields:</p> <pre><code>app.post('/process-event', verifyBearerToken, (req: Request, res: Response) =&gt; {\n    const { data, pb_data } = req.body;\n\n    const eventType = data?.event_type;\n    const billStatus = pb_data?.account_info?.bill_status;\n\n    if (!eventType || !billStatus) {\n        return res.status(422).json({\n            message: 'Validation failed',\n            error: 'Validation failed',\n            type: 'VALIDATION_ERROR',\n        });\n    }\n\n    console.log('Received event:', eventType, '| bill status:', billStatus);\n\n    res.status(202).json({ message: 'Event accepted for processing' });\n});\n</code></pre>"},{"location":"examples/typescript/simple-connector-express/overview.html#how-to-run-locally","title":"How to run locally","text":"<ol> <li>Copy <code>.env.example</code> to <code>.env</code> and set <code>API_TOKEN</code> and <code>PORT</code>.</li> <li>Install dependencies and build (using npm or yarn). Example with npm:</li> </ol> <pre><code>npm install; npm run build; npm start\n</code></pre> <ol> <li>For development with automatic reload you can use <code>nodemon</code>.</li> </ol>"},{"location":"examples/typescript/simple-connector-express/overview.html#notes","title":"Notes","text":"<ul> <li>This example is intentionally minimal. For production-ready connectors consider adding request validation (e.g., using zod or Joi), structured logging, health checks, graceful shutdown, and tests.</li> <li>Ensure the <code>API_TOKEN</code> configured in the NSPS Handler matches the connector's <code>API_TOKEN</code>.</li> </ul> <p>Also see README file</p>"},{"location":"implementation-specific/best-practices.html","title":"Best Practices","text":"<p>This section gathers practical, actionable guidance for building reliable, secure, and maintainable NSPS connectors. It focuses on patterns that matter most in production: authentication and security, input validation, error handling, response and event processing.</p> <p>Each best practice includes why it matters, a short step-by-step implementation guide, and concise examples in <code>TypeScript</code> (<code>Express</code>) and <code>Python</code> (<code>FastAPI</code>), adapted from the example connectors in this repository.</p> <p>Following these practices ensures your connector:</p> <ul> <li>Authenticates all incoming requests using the NSPS Bearer token.</li> <li>Validates incoming events to prevent processing invalid or malformed data.</li> <li>Responds to every event, both on success and error, to maintain proper acknowledgment and a complete audit trail in NSPS.</li> <li>Uses consistent error formats for predictable handling by NSPS.</li> </ul>"},{"location":"implementation-specific/best-practices.html#authorization","title":"Authorization","text":"<p>The NSPS Connector uses a Bearer Token to authenticate incoming requests from the NSPS platform. This token is a static secret key, registered and configured in NSPS. Every message sent from NSPS to the Connector is signed with this token, and the Connector must validate it before processing the request.</p>"},{"location":"implementation-specific/best-practices.html#1-using-the-bearer-token","title":"1. Using the Bearer Token","text":"<p>Header format:</p> <pre><code>Authorization: Bearer &lt;YOUR_API_TOKEN&gt;\n</code></pre> <p>Each incoming request from NSPS must include this header to be accepted by the Connector.</p>"},{"location":"implementation-specific/best-practices.html#2-token-verification","title":"2. Token Verification","text":"TypeScriptPython <pre><code>import { Request, Response, NextFunction } from 'express';\nimport { settings } from './core/config';\n\nexport function verifyToken(req: Request, res: Response, next: NextFunction) {\n    const authHeader = req.headers.authorization;\n    const token = authHeader?.startsWith('Bearer ') ? authHeader.split(' ')[1] : null;\n\n    if (!token || token !== settings.API_TOKEN) {\n        return res\n            .status(401)\n            .set('WWW-Authenticate', 'Bearer')\n            .json({\n                message: 'Invalid access token',\n                error: 'Unauthorized',\n                type: 'AUTHENTICATION_ERROR',\n            });\n    }\n\n    next();\n}\n</code></pre> verify_token.py<pre><code>from fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom .core.config import settings\n\nsecurity = HTTPBearer()\n\ndef verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    \"\"\"Verify the Bearer token provided by NSPS\"\"\"\n    if credentials.credentials != settings.API_TOKEN:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid access token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    return credentials.credentials\n</code></pre> <p>How it works:</p> <ul> <li> <p>Extracts the Bearer token from the request header.</p> </li> <li> <p>Compares it with the configured value in <code>settings.API_TOKEN</code>.</p> </li> <li> <p>Raises an <code>HTTP 401 error</code> if the token does not match.</p> </li> </ul>"},{"location":"implementation-specific/best-practices.html#3-secure-token-storage","title":"3. Secure Token Storage","text":""},{"location":"implementation-specific/best-practices.html#recommended-storage-options","title":"Recommended storage options:","text":""},{"location":"implementation-specific/best-practices.html#1-environment-file-env","title":"1. Environment file (<code>.env</code>)","text":"<p>Store the token as an environment variable in your deployment environment or in a <code>.env</code> file duringlocal development:</p> .env<pre><code>API_TOKEN=your_secret_token_here\n</code></pre> <p>Best practices for environment variables:</p> <ul> <li>Add <code>.env</code> files to <code>.gitignore</code> so they are not committed to version control.</li> <li>Use different tokens for development, staging, and production environments.</li> <li>Keep <code>.env</code> files outside of your code repository if possible.</li> </ul>"},{"location":"implementation-specific/best-practices.html#2-secrets-store-or-vault","title":"2. Secrets Store or Vault","text":"<p>In production environments, use a secure secret management system instead of plain <code>.env</code> files:</p> <ul> <li>AWS Secrets Manager</li> <li>HashiCorp Vault</li> <li>Azure Key Vault</li> <li>Google Secret Manager</li> </ul>"},{"location":"implementation-specific/best-practices.html#load-values-via-the-configuration-system","title":"Load values \u200b\u200bvia the configuration system:","text":"TypeScriptPython settings.ts<pre><code>import { config as loadEnv } from 'dotenv';\nimport { z } from 'zod';\n\nloadEnv();\n\nconst EnvSchema = z.object({\n    API_TOKEN: z.string().min(1, 'API_TOKEN is required'),\n});\n\nexport const settings = EnvSchema.parse(process.env);\n</code></pre> settings.py<pre><code>from pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    API_TOKEN: str\n\n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()\n</code></pre> <p>This ensures your app automatically reads variables from <code>.env</code> or from environment configuration (e.g., Docker, Kubernetes, or CI/CD).</p>"},{"location":"implementation-specific/best-practices.html#4-unauthorized-access-response","title":"4. Unauthorized Access Response","text":"<p>If the provided token is invalid or missing, the Connector must return an <code>HTTP 401 Unauthorized</code> response. The response must be formatted in accordance with ErrorResponse</p> <p>Response example:</p> response.json<pre><code>{\n    \"message\": \"Invalid access token\",\n    \"error\": \"Unauthorized\",\n    \"type\": \"AUTHENTICATION_ERROR\"\n}\n</code></pre>"},{"location":"implementation-specific/best-practices.html#input-validation","title":"Input Validation","text":"<p>Before processing, each NSPS event must be validated to ensure it matches the expected schema. Validation guarantees data integrity, prevents processing of incomplete payloads, and protects the connector from runtime errors.</p>"},{"location":"implementation-specific/best-practices.html#1-why-input-validation-matters","title":"1. Why Input Validation Matters","text":"<ul> <li>Ensures that only well-formed events are processed.</li> <li>Prevents null or malformed fields from causing downstream issues.</li> <li>Enables predictable, auditable, and safe event handling.</li> </ul> Example request: <pre><code>{\n    \"event_id\": \"3e84c79f-ab6f-4546-8e27-0b6ab866f1fb\",\n    \"data\": {\n        \"event_type\": \"SIM/Updated\"\n    },\n    \"pb_data\": {\n        \"sim_info\": {\n        \"imsi\": \"001010000020349\"\n        }\n    }\n}\n</code></pre>"},{"location":"implementation-specific/best-practices.html#2-validation-example","title":"2. Validation Example","text":"TypeScriptPython index.ts<pre><code>import express, { Request, Response } from 'express';\nimport { z, ZodError } from 'zod';\n\n// ...\n\n// --- Zod schemas ---\nconst SimInfoSchema = z.object({\n    imsi: z\n        .string()\n        .regex(/^[0-9]{15}$/, 'IMSI must contain exactly 15 digits')\n        .optional(),\n});\n\nconst PBDataSchema = z.object({\n    sim_info: SimInfoSchema,\n});\n\nconst EventDataSchema = z.object({\n    event_type: z.string(),\n});\n\nconst EventSchema = z.object({\n    event_id: z.string(),\n    data: EventDataSchema,\n    pb_data: PBDataSchema,\n});\n\napp.post('/process-event', verifyBearerToken, (req: Request, res: Response) =&gt; {\n    try {\n        const event = EventSchema.parse(req.body);\n        // Validation passed, process the event\n\n        // ...\n    } catch (e) {\n        if (e instanceof ZodError) {\n            return res.status(422).json({\n                message: 'Validation failed',\n                error: 'Validation failed',\n                type: 'VALIDATION_ERROR',\n                details: e.errors,\n            });\n        }\n\n        // ...\n    }\n});\n</code></pre> <pre><code>from fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel, constr, ValidationError\n\n# ...\n\nclass SimInfo(BaseModel):\n    imsi: constr(regex=r'^[0-9]{15}$') | None = None\n\nclass PBData(BaseModel):\n    sim_info: SimInfo\n\nclass EventData(BaseModel):\n    event_type: str\n\nclass Event(BaseModel):\n    event_id: str\n    data: EventData\n    pb_data: PBData\n\n@app.post(\n    '/process-event',\n    # ...\n    responses={\n        # ...\n        422: {\n            \"model\": ErrorResponse,\n            \"description\": \"Validation failed\",\n            \"content\": {\n                \"application/json\": {\n                    \"example\": {\n                        \"message\": \"Validation failed\",\n                        \"error\": \"Validation failed\",\n                        \"type\": ErrorType.VALIDATION_ERROR,\n                    }\n                }\n            },\n        }\n    },\n)\nasync def process_event(event: Event, token: str = Depends(verify_bearer_token)):\n    try:\n        # Pydantic will validate types and regex before this code runs\n    except ValidationError as e:\n        error_response = {\"errors\": e.errors()}\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=error_response\n        )\n</code></pre> <p>Validation should be explicit for fields that drive routing or external API calls (IMSI, action types, resource IDs). Keep validation rules in small reusable modules so they can be unit-tested.</p>"},{"location":"implementation-specific/best-practices.html#3-validation-failure-response","title":"3. Validation Failure Response","text":"<p>If the payload does not pass validation, the connector must respond with <code>HTTP 422 Unprocessable</code> Entity and include validation details. ErrorResponse</p> <pre><code>{\n    \"message\": \"Validation failed\",\n    \"error\": \"Validation failed\",\n    \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre>"},{"location":"implementation-specific/best-practices.html#sending-responses-to-nsps","title":"Sending Responses to NSPS","text":"<p>A recommended best practice when implementing the NSPS Connector is to always send a response back to NSPS after processing each event, regardless of whether the processing was successful or resulted in an error. This ensures that:</p> <ul> <li> <p>Event acknowledgment: NSPS knows the event has been received and processed.</p> </li> <li> <p>Audit trail completeness: All responses, including success and error messages, are stored in the Event History database, providing a complete audit trail accessible via the Management UI.</p> </li> <li> <p>Error visibility: Sending detailed error responses helps NSPS track issues and aids in debugging and programmatic handling.</p> </li> </ul> <p>Success response example:</p> 202 Accepted: Event accepted for processing<pre><code>{\n    \"message\": \"Event accepted for processing\"\n}\n</code></pre> <p>Error response example:</p> 500 Internal Server Error: Processing error<pre><code>{\n    \"message\": \"Error processing event\",\n    \"error\": \"External system connection failed\",\n    \"type\": \"CONNECTION_ERROR\"\n}\n</code></pre> <p>More info here Error Response Structure.</p> <p>By consistently responding to every NSPS event, your connector provides reliable feedback, maintains data integrity, and ensures that NSPS can correctly log and analyze all processed events.</p>"},{"location":"implementation-specific/configuration.html","title":"Configuration","text":"<p>Typically, a connector should contain parameters that are needed to connect to the external system, as well as some that are needed by the application itself. The simplest and most straightforward option is to pass environment variables.</p> <p>The connector must verify all requests by checking the Bearer token. Therefore, there is a need to set this token in the connector. It is recommended to set it as an environment variable (e.g., <code>API_TOKEN</code>) and read it in the code. This way, by changing only the environment variable, you can quickly update the access token in case it is compromised.</p> <p>Requirements:</p> <ul> <li>Configurable bearer token to access the service.</li> <li>Configurable external system credentials.</li> </ul>"},{"location":"implementation-specific/error-handling.html","title":"Error Handling","text":"<p>Proper error handling ensures that NSPS connectors provide clear feedback for every event, maintain a complete audit trail, and allow programmatic handling of failures.</p> <ul> <li>Errors should be logged.</li> <li>Each error response must contain a JSON body with an explanation of the reason for the error.</li> </ul>"},{"location":"implementation-specific/error-handling.html#error-response-structure","title":"Error Response Structure","text":"<p>All error responses must follow the <code>ErrorResponse</code> schema:</p> <pre><code>{\n    \"message\": \"Detailed description of the error\",\n    \"error\": \"Specific failure reason\",\n    \"type\": \"ERROR_TYPE\"\n}\n</code></pre> <p>Error Response Fields:</p> <ul> <li><code>message</code>: General description of the operation result (used in successful responses).</li> <li><code>error</code>: Detailed error description, indicates failure processing results.</li> <li><code>type</code>: Error type for programmatic handling. Example:</li> </ul> <pre><code>\"VALIDATION_ERROR\"\n\"AUTHENTICATION_ERROR\"\n\"SERVICE_ERROR\"\n\"CONNECTION_ERROR\"\n\"RATE_LIMIT_ERROR\"\n\"INTERNAL_ERROR\"\n</code></pre>"},{"location":"implementation-specific/error-handling.html#standard-responses-examples","title":"Standard Responses Examples","text":"<p>All response codes, messages, and error details are stored in the Event History database and are available for analysis via the Management UI. This provides a complete audit trail of all events processed by the system.</p> <p>202 Accepted \u2013 Event accepted for processing:</p> <pre><code>{\n    \"message\": \"Event accepted for processing\"\n}\n</code></pre> <p>401 Unauthorized \u2013 Invalid access token:</p> <pre><code>{\n    \"message\": \"Invalid access token\",\n    \"error\": \"Unauthorized\",\n    \"type\": \"AUTHENTICATION_ERROR\"\n}\n</code></pre> <p>404 Not Found \u2013 Resource not found:</p> <pre><code>{\n    \"message\": \"Resource not found\",\n    \"error\": \"Not found\",\n    \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre> <p>405 Method Not Allowed \u2013 HTTP method not supported:</p> <pre><code>{\n    \"message\": \"Method not allowed\",\n    \"error\": \"Method not allowed\",\n    \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre> <p>422 Unprocessable Entity \u2013 Validation failed:</p> <pre><code>{\n    \"message\": \"Validation failed\",\n    \"error\": \"Validation failed\",\n    \"type\": \"VALIDATION_ERROR\"\n}\n</code></pre> <p>429 Too Many Requests \u2013 Rate limit exceeded:</p> <pre><code>{\n    \"message\": \"Too many requests to API Core\",\n    \"error\": \"Rate limit exceeded\",\n    \"type\": \"RATE_LIMIT_ERROR\"\n}\n</code></pre> <p>500 Internal Server Error \u2013 API or service error:</p> <pre><code>{\n    \"message\": \"API Core HTTP error\",\n    \"error\": \"Internal server error\",\n    \"type\": \"SERVICE_ERROR\"\n}\n</code></pre> <p>503 Service Unavailable \u2013 Core service not available:</p> <pre><code>{\n    \"message\": \"Core service is not available\",\n    \"error\": \"Connection timeout\",\n    \"type\": \"CONNECTION_ERROR\"\n}\n</code></pre>"},{"location":"implementation-specific/logging.html","title":"Logging","text":"<p>Logging is an important part that allows debugging when necessary.</p> <p>Requirements:</p> <ul> <li>Logs should be written in JSON format (for search integration).</li> <li>Log <code>x-b3-traceid</code> header to <code>request_id</code> field.</li> <li>Log <code>x-request-id</code> header to <code>unique_id</code> field.</li> </ul> <p>Logging these headers allows you to track all the events that occur with the event from its very beginning \u2014 entering the NSPS.</p>"},{"location":"implementation-specific/requirements.html","title":"Requirements","text":"<ul> <li>Authentication of all requests to the connector using a Bearer token.</li> <li>Event payload schema parsing.</li> <li>Handling specific events (e.g., SIM activated, Plan changed, etc.).</li> <li>Configurable settings for External API server:<ul> <li>API base URL with optional base path.</li> <li>API access credentials (depends on the system implementation. This can be either Basic Auth, Bearer Auth with a static token, or support for example JWT. The connector should work with access_tokens and refresh_tokens if the system requires it).</li> </ul> </li> <li>Response codes:<ul> <li>2XX for a successfully processed event (with optional JSON response body).</li> <li>4XX and 5XX codes for unsuccessfully processed events (with human-readable error explanation in response JSON body).</li> </ul> </li> </ul> <p>An example is available here - WTL HLR/HSS Connector.</p> <p>The connector should provide 2 methods:</p> <ol> <li>GET health endpoint is needed to check the availability of the connector itself (this method should return just 200 OK with some optional response body).</li> <li>POST method is used by the NSPS system as a destination. The URL may or may not contain a path (options such as <code>https://connector.com</code>, <code>https://connector.com/api/events</code> are OK).</li> </ol> <p>You can view or download an example of the OpenAPI specification below.</p> <p></p> <p>Click here to view/download OpenAPI spec</p>"},{"location":"implementation-specific/request-handling/event-types.html","title":"Event Types","text":""},{"location":"implementation-specific/request-handling/event-types.html#simupdated","title":"SIM/Updated","text":""},{"location":"implementation-specific/request-handling/event-types.html#trigger-conditions","title":"Trigger conditions","text":"<ul> <li>SIM card details have been changed, e.g., the default PIN for inactive SIM cards has been changed.</li> <li>The SIM card data specified in a custom field has been changed, e.g., the \u201cAmazon\u201d value is set in the \u201cMarketplace\u201d custom field.</li> <li>SIM card status has been changed, e.g., from \u201cIn use\u201d to \u201cDisposed\u201d.</li> <li>An account\u2019s ID has changed. (Account.id has been updated.)</li> <li>Another product was assigned to the account. An account\u2019s product has changed. (Account.i_product has been updated.)</li> <li>An account\u2019s add-on product has been changed.</li> <li>An add-on product has been removed from an account.</li> <li>A new add-on product has been added for an account.</li> <li>The user has topped up (\u201crecharged\u201d) their bundle of any service type to get more service volume before bundle renewal.</li> <li>An account has exceeded its service usage quota (for services of all types except Messaging and Internet access).</li> <li>A service feature has been enabled/disabled for an account (the Service_Attribute_Values table has been updated).</li> <li>Custom information (e.g., ID card) has been added or changed for an account. (The Custom_Field_Values table has been updated for the account.)</li> <li>An account\u2019s billing status has been changed or affected by the customer\u2019s billing status. A customer\u2019s status has changed. (Customers.bill_status has changed.)</li> <li>An account has been blocked. (Accounts.blocked set to \u2018Y.\u2019)</li> <li>An account has been unblocked. (Accounts.blocked set to \u2018N.\u2019)</li> <li>Bundle is successfully activated for the first time (the bundle has never been activated for this account before).</li> <li>Bundle is assigned to the account.</li> <li>Bundle has expired (for bundles of the balance-dependant renewable type).</li> <li>Grace period for the bundle is over (for balance-dependant renewable type).</li> <li>Bundle is removed from the account.</li> <li>Bundle is automatically renewed for the account (for bundles of the balance-dependant renewable type).</li> <li>Bundle is successfully activated after expiration (for bundles of the balance-dependant renewable type).</li> </ul>"},{"location":"implementation-specific/request-handling/event-types.html#most-used-fields","title":"Most used fields","text":"<ul> <li><code>pb_data.sim_info.imsi</code></li> <li><code>pb_data.account_info.i_account</code></li> <li><code>pb_data.account_info.i_product</code></li> <li><code>pb_data.account_info.bill_status</code></li> <li><code>pb_data.account_info.blocked</code></li> <li><code>pb_data.account_info.product_name</code></li> <li><code>pb_data.account_info.assigned_addons[].i_product</code></li> <li><code>pb_data.account_info.assigned_addons[].name</code></li> <li><code>pb_data.account_info.assigned_addons[].i_vd_plan</code></li> <li><code>pb_data.access_policy_info.attributes[\"name\"==\"cs_profile\"].values[0]</code></li> <li><code>pb_data.access_policy_info.attributes[\"name\"==\"eps_profile\"].values[0]</code></li> </ul>"},{"location":"implementation-specific/request-handling/event-types.html#simcreated","title":"SIM/Created","text":""},{"location":"implementation-specific/request-handling/event-types.html#trigger-conditions_1","title":"Trigger conditions","text":"<ul> <li>A SIM card has been added to the inventory.</li> </ul>"},{"location":"implementation-specific/request-handling/event-types.html#most-used-fields_1","title":"Most used fields","text":"<ul> <li><code>pb_data.sim_info.imsi</code></li> <li><code>pb_data.account_info.i_account</code></li> </ul>"},{"location":"implementation-specific/request-handling/event-types.html#simdeleted","title":"SIM/Deleted","text":""},{"location":"implementation-specific/request-handling/event-types.html#trigger-conditions_2","title":"Trigger conditions","text":"<ul> <li>A SIM card has been removed from the inventory.</li> </ul>"},{"location":"implementation-specific/request-handling/event-types.html#most-used-fields_2","title":"Most used fields","text":"<ul> <li><code>pb_data.sim_info.imsi</code></li> <li><code>pb_data.account_info.i_account</code></li> </ul>"},{"location":"implementation-specific/request-handling/event-types.html#simreplaced","title":"SIM/Replaced","text":""},{"location":"implementation-specific/request-handling/event-types.html#trigger-conditions_3","title":"Trigger conditions","text":"<ul> <li>A SIM card has been assigned to, removed from, or changed for an account.</li> </ul>"},{"location":"implementation-specific/request-handling/event-types.html#most-used-fields_3","title":"Most used fields","text":"<ul> <li><code>pb_data.sim_info</code></li> <li><code>pb_data.prev_sim_info</code></li> </ul>"},{"location":"implementation-specific/request-handling/request-body.html","title":"Request Body","text":""},{"location":"implementation-specific/request-handling/request-body.html#espf-event-data","title":"ESPF Event Data","text":"<p>The ESPF event generated by EventSender contains a limited set of variables (<code>event_type</code>, <code>i_account</code>, <code>i_env</code>, etc.), but external systems usually require more information (about the main product, add-ons, used quotas, etc.).</p> Example of NSPF event <pre><code>    {\n        \"event_type\":\"SIM/Updated\",\n        \"variables\":{\n          \"i_env\":3,\n          \"i_event\":999999,\n          \"i_account\":277147,\n          \"event_time\":\"2025-05-01 12:00:00\"\n        }\n    }\n</code></pre> <p>Therefore, the NSPS system makes API requests api-requests to PortaBilling in order to get more information about the account, SIM, etc., which relates to the created event. The NSPS adds all the necessary data and passes it to the connector.</p> <p>NSPS sends the following request body to the connector (so the connector should accept it):</p> Field Name Mandatory Description <code>pb_data</code> No Enriched data from PortaBilling; includes account, SIM, and access policy info. Defaults empty. <code>data</code> Yes Event payload, represented by an instance of <code>ESPFEvent</code>. <code>handler_id</code> No Optional identifier of the handler assigned to process the event. <code>status</code> No Status of event processing. Defaults to <code>EventStatus.UNDEFINED</code>. <code>created_at</code> No Timestamp when the event was created. <code>updated_at</code> No Timestamp when the event was last enriched by NSPS. <code>event_id</code> Yes Unique identifier of the event. <p>The field called <code>data</code> contains the generated ESPF event as it is. So if you don't need additional info from PortaBilling, you can only use this data.</p> <p>The data structure for the <code>PortaBillingData</code> (<code>pb_data</code>) is shown below. It includes all possible fields. The connector should contain logic to process only the parameters it needs, and unnecessary ones can be ignored.</p> <p>For a more detailed description of the parameters, please refer to docs.portaone.com.</p>"},{"location":"implementation-specific/request-handling/request-body.html#portabilling-data","title":"PortaBilling Data","text":"<p>Type: <code>PortaBillingData</code></p> <p>This section contains enriched data received from PortaBilling. It provides detailed information about the account, SIM card, products, features, policies, and usage counters associated with the subscriber.</p> Field Path Type Description <code>account_info</code> <code>AccountInfo</code> Main account-level data container. <code>sim_info</code> <code>SimInfo</code> SIM card information from PortaBilling. <code>prev_sim_info</code> <code>SimInfo</code> Previous SIM card information (used for SIM/Replaced events). <code>access_policy_info</code> <code>List[</code><code>AccessPolicyInfo</code><code>]</code> Access policy information from PortaBilling. <code>product_info</code> <code>ProductInfo</code> Product information from PortaBilling. <code>full_vd_counter_info</code> <code>List[</code><code>VDCounterInfo</code><code>]</code> VD counter information from PortaBilling."},{"location":"implementation-specific/request-handling/request-body.html#account-info","title":"Account Info","text":"<p>Type: <code>AccountInfo</code></p> <p>Relation: <code>account_info</code>: <code>AccountInfo</code> in <code>PortaBillingData</code> (<code>pb_data</code>)</p> <p>The main account-level data container. It provides billing information, account status, assigned product, customer relations, and owner\u2019s contact details.</p> Field Path Type Description <code>bill_status</code> <code>str</code> The billing status of the account. (1) <code>billing_model</code> <code>str</code> The account type. (2) <code>blocked</code> <code>bool</code> Boolean conversion - Indicates whether account's calls and access to the self-care interface is blocked. (3) <code>email</code> <code>str</code> The email address associated with the account. <code>firstname</code> <code>str</code> The account owner's first name. <code>i_account</code> <code>int</code> Internal ID of the account. Visible in URL resource path on Admin UI page. <code>i_customer</code> <code>int</code> The ID of the customer record to which the account belongs. <code>i_master_account</code> <code>int</code> The ID of the parent account. <code>i_product</code> <code>int</code> The ID for the account's product. <code>i_vd_plan</code> <code>int</code> The unique ID of the bundle assigned to the account individually. <code>id</code> <code>str</code> Charging ID (MSISDN, ICCID or IMSI) of the account on the network. Visible as ID in Admin UI. <code>lastname</code> <code>str</code> The account owner's last name. <code>phone1</code> <code>str</code> The main phone number. <code>product_name</code> <code>str</code> The name of the account's product. <code>status</code> <code>str</code> The current status of the account based on factors such as \"expiration time\", \"activation time\" and so on. (4) <code>time_zone_name</code> <code>str</code> The name of the account's time zone. (5) <code>zip</code> <code>str</code> The postal (zip) code. <code>assigned_addons</code> <code>List[</code><code>AssignedAddon</code><code>]</code> List of account's add-on products. <code>service_features</code> <code>List[</code><code>AssignedAddon</code><code>]</code> List of service features. <ol> <li>Mapped values (originally single-letter codes):<ul> <li><code>O</code> \u2192 active</li> <li><code>S</code> \u2192 suspended</li> <li><code>I</code> \u2192 inactive</li> <li><code>C</code> \u2192 terminated</li> </ul> </li> <li>Mapped values (originally int codes):<ul> <li>-1 \u2192 debit_account</li> <li>0 \u2192 recharge_voucher</li> <li>1 \u2192 credit_account</li> <li>2 \u2192 alias</li> <li>4 \u2192 beneficiary</li> </ul> </li> <li>originally <code>Y/N</code> <code>string</code>, converted <code>Y</code> \u2192 <code>False</code>, <code>N</code> \u2192 <code>True</code></li> <li>Possible values:<ul> <li><code>active</code></li> <li><code>customer_exported</code></li> <li><code>expired</code></li> <li><code>quarantine</code></li> <li><code>screening</code></li> <li><code>closed</code></li> <li><code>inactive</code></li> <li><code>customer_suspended</code></li> <li><code>customer_limited</code></li> <li><code>customer_provisionally_terminated</code></li> <li><code>blocked</code></li> <li><code>customer_blocked</code></li> <li><code>not_yet_active</code></li> <li><code>credit_exceeded</code></li> <li><code>overdraft</code></li> <li><code>customer_has_no_available_funds</code></li> <li><code>customer_credit_exceed</code></li> <li><code>zero_balance</code></li> <li><code>customer_suspension_delayed</code></li> <li><code>customer_limiting_delayed</code></li> <li><code>frozen</code></li> </ul> </li> <li>Examples: \"Europe/Prague\", \"America/Vancouver\", etc.</li> </ol> Example: <code>AccountInfo</code> <pre><code>{\n    \"bill_status\": \"open\",\n    \"billing_model\": \"credit_account\",\n    \"blocked\": false,\n    \"i_account\": 1,\n    \"i_customer\": 6392,\n    \"i_product\": 3774,\n    \"id\": \"79123456789@msisdn\",\n    \"phone1\": \"\",\n    \"product_name\": \"wtl Pay as you go\",\n    \"time_zone_name\": \"Europe/Prague\",\n    \"assigned_addons\": [\n        {\n            \"addon_effective_from\": \"2025-05-16T12:59:46\",\n            \"addon_priority\": 10,\n            \"description\": \"\",\n            \"i_product\": 3775,\n            \"i_vd_plan\": 1591,\n            \"name\": \"wtl Youtube UHD\"\n        }\n    ],\n    \"service_features\": [\n        {\n            \"name\": \"netaccess_policy\",\n            \"effective_flag_value\": \"Y\",\n            \"attributes\": [\n                {\n                    \"name\": \"access_policy\",\n                    \"effective_value\": \"179\"\n                }\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"implementation-specific/request-handling/request-body.html#assigned-add-on","title":"Assigned Add-on","text":"<p>Type: <code>AssignedAddon</code></p> <p>Relation: <code>assigned_addons</code>: <code>List[AssignedAddon]</code> in <code>AccountInfo</code> (<code>account_info</code>)</p> <p>The list of the account's add-on products</p> Field Path Type Description <code>addon_effective_from</code> <code>str</code> ISO datetime string - The date and time when the add-on product is activated for an account. (1) <code>addon_effective_to</code> <code>str</code> ISO datetime string - The date and time when the add-on product assigned to an account expires. (2) <code>addon_priority</code> <code>int</code> The priority level of the add-on product. <code>description</code> <code>str</code> The internal product description. <code>i_product</code> <code>int</code> The unique ID of the product. <code>i_product_group</code> <code>int</code> The unique ID of the product group to which the product belongs. <code>i_vd_plan</code> <code>int</code> The unique ID of the bundle assigned to the product. <code>name</code> <code>str</code> The product name. <ol> <li>Originally <code>Optional[str]</code> datetime</li> <li>Originally <code>Optional[str]</code> datetime</li> </ol> Example: <code>AssignedAddon</code> <pre><code>    {\n        \"addon_effective_from\": \"2025-05-16T12:59:46\",\n        \"addon_priority\": 10,\n        \"description\": \"\",\n        \"i_product\": 3775,\n        \"i_vd_plan\": 1591,\n        \"name\": \"wtl Youtube UHD\"\n    }\n</code></pre>"},{"location":"implementation-specific/request-handling/request-body.html#service-feature","title":"Service Feature","text":"<p>Type: <code>ServiceFeature</code></p> <p>Relation: <code>service_features</code>: <code>List[ServiceFeature]</code> in <code>AccountInfo</code> (<code>account_info</code>)</p> <p>List of service features assigned to the account, each with its attributes.</p> Field Path Type Description <code>name</code> <code>str</code> The service feature name. <code>effective_flag_value</code> <code>str</code> The actual service feature flag value. (1) <code>attributes</code> <code>List[ServiceFeatureAttribute]</code> The list of service feature attributes. <code>attributes[].name</code> <code>str</code> The service feature attribute internal name. <code>attributes[].effective_value</code> <code>str</code> Service feature attribute value, comma-separated if multiple values. <ol> <li>Possible values:<ul> <li><code>Y</code> \u2192 enabled</li> <li><code>N</code> \u2192 disabled</li> </ul> </li> </ol> Example: <code>ServiceFeature</code> <pre><code>    {\n        \"name\": \"netaccess_policy\",\n        \"effective_flag_value\": \"Y\",\n        \"attributes\": [\n            {\n                \"name\": \"access_policy\",\n                \"effective_value\": \"179\"\n            }\n        ]\n    }\n</code></pre>"},{"location":"implementation-specific/request-handling/request-body.html#sim-info","title":"SIM Info","text":"<p>Type: <code>SimInfo</code></p> <p>Relation:</p> <ul> <li><code>sim_info</code>: <code>SimInfo</code> in <code>PortaBillingData</code> (<code>pb_data</code>)</li> <li><code>prev_sim_info</code>: <code>SimInfo</code> in <code>PortaBillingData</code> (<code>pb_data</code>)</li> </ul> <p>SIM card information from PortaBilling</p> Field Path Type Description <code>i_account</code> <code>int</code> The unique ID of the account to which the SIM card belongs. <code>i_sim_card</code> <code>int</code> The unique ID of the SIM card. <code>iccid</code> <code>str</code> The Integrated Circuit Card ID. <code>imsi</code> <code>str</code> The unique International Mobile Subscriber Identity of the SIM card. <code>msisdn</code> <code>str</code> The Mobile Subscriber Integrated Services Digital Number. <code>status</code> <code>str</code> The status of the SIM card. (1) <ol> <li>Possible values:<ul> <li><code>available</code> \u2192 the SIM card is available for assignment,</li> <li><code>reserved</code> \u2192 reserved for the customer, but not yet assigned to the account,</li> <li><code>used</code> \u2192 SIM card is being used by the account,</li> <li><code>disposed</code> \u2192 SIM card is disposed and cannot be used.</li> </ul> </li> </ol> Example: <code>SimInfo</code> <pre><code>    {\n        \"i_sim_card\": 3793,\n        \"imsi\": \"001010000020349\",\n        \"msisdn\": \"79123456789\",\n        \"status\": \"active\"\n    }\n</code></pre>"},{"location":"implementation-specific/request-handling/request-body.html#access-policy-info","title":"Access Policy Info","text":"<p>Type: <code>AccessPolicyInfo</code></p> <p>Relation: <code>access_policy_info</code>: <code>AccessPolicyInfo</code> in <code>PortaBillingData</code> (<code>pb_data</code>)</p> <p>Information about access policies applied to the account.</p> Field Path Type Description <code>i_access_policy</code> <code>int</code> The unique ID of the Access Policy. <code>name</code> <code>str</code> The name of the Access Policy. <code>attributes</code> <code>List[AccessPolicyAttribute]</code> The list of related service policy attribute values. <code>attributes[].group_name</code> <code>str</code> The name used to group service policy attributes. <code>attributes[].name</code> <code>str</code> The name of the service policy attribute. <code>attributes[].value</code> <code>str</code> Service policy attribute value, comma-separated if multiple values. Example: <code>AccessPolicyInfo</code> <pre><code>    {\n        \"i_access_policy\":179,\n        \"name\":\"WTL integration test\",\n        \"attributes\":[\n            {\n                \"group_name\":\"lte.wtl\",\n                \"name\":\"cs_profile\",\n                \"value\":\"cs-pp-20250319\"\n            },\n            {\n                \"group_name\":\"lte.wtl\",\n                \"name\":\"eps_profile\",\n                \"value\":\"eps-pp-20250319\"\n            }\n        ]\n    }\n</code></pre>"},{"location":"implementation-specific/request-handling/request-body.html#product-info","title":"Product Info","text":"<p>Type: <code>ProductInfo</code></p> <p>Relation: <code>product_info</code>: <code>ProductInfo</code> in <code>PortaBillingData</code> (<code>pb_data</code>)</p> <p>Product information from PortaBilling</p> Field Path Type Description <code>name</code> <code>str</code> The product name. <code>description</code> <code>str</code> The internal product description. <code>i_product</code> <code>int</code> The unique ID of the product. <code>i_vd_plan</code> <code>int</code> The unique ID of the bundle assigned to the product.  <code>addon_priority</code> <code>int</code> The priority level of the add-on product. (1) <ol> <li> <ul> <li>0 \u2192 main product</li> <li>10 \u2192 low</li> <li>15 \u2192 medium low</li> <li>20 \u2192 medium</li> <li>25 \u2192 medium high</li> <li>30 \u2192 high</li> </ul> </li> </ol> Example: <code>ProductInfo</code> <pre><code>    {\n        \"name\":\"DEV WTL Pay as you go\",\n        \"description\":\"\",\n        \"addon_priority\":0,\n        \"i_product\":658\n    }\n</code></pre>"},{"location":"implementation-specific/request-handling/request-body.html#vd-counter-info","title":"VD Counter Info","text":"<p>Type: <code>VDCounterInfo</code></p> <p>Relation: <code>full_vd_counter_info</code>: <code>List[VDCounterInfo]</code> in <code>PortaBillingData</code> (<code>pb_data</code>)</p> <p>VD counter information from PortaBilling</p> Field Path Type Description <code>discount_info</code> <code>str</code> Short representation of the discount details (e.g., '0..60 - 100%'). <code>dg_name</code> <code>str</code> The name of the destination group the bundle item is applied to. <code>i_vd_plan</code> <code>int</code> The unique ID of the bundle. <code>i_dest_group</code> <code>int</code> The unique ID of the destination group the discount is applied to. <code>allocated_amount</code> <code>float</code> The total amount of service volume allocated to the customer/account in the current usage period. <code>unit</code> <code>str</code> The name of the service unit or currency used. <code>addon_priority</code> <code>int</code> The priority level of the bundle item. (1) <code>vdp_name</code> <code>str</code> The name of the bundle. <code>i_vd_dg</code> <code>int</code> The unique ID of the bundle item. <code>i_service</code> <code>int</code> The unique ID of the service. <code>service_name</code> <code>str</code> The name of the service the discount is applied to. <code>remaining</code> <code>float/str</code> The service volume that remains to be used to reach the current threshold. (2) <ol> <li>Possible values:<ul> <li>-1 \u2192 no priority</li> <li>0 \u2192 main product</li> <li>10 \u2192 low</li> <li>12 \u2192 bundled credit wallets</li> <li>13 \u2192 bundled credits</li> <li>14 \u2192 bundled credit preferred wallets</li> <li>15 \u2192 medium low</li> <li>20 \u2192 medium</li> <li>25 \u2192 medium high</li> <li>30 \u2192 high</li> <li>255 \u2192 not part of a product</li> </ul> </li> <li>Can be numeric value or string like <code>N/A</code></li> </ol> Example: <code>VDCounterInfo</code> <pre><code>    {\n        \"service_name\":\"Internet Access KB\",\n        \"vdp_name\":\"DEV WTL Free 10MB (1 day)\",\n        \"i_vd_plan\":204,\n        \"i_dest_group\":2650,\n        \"addon_priority\":10,\n        \"i_vd_dg\":283,\n        \"remaining\":\"10\",\n        \"i_service\":106,\n        \"dg_name\":\"RG100\",\n        \"discount_info\":\"0..10 - 100%\",\n        \"unit\":\"megabyte\",\n        \"allocated_amount\":10\n    }\n</code></pre>"},{"location":"implementation-specific/request-handling/request-headers.html","title":"Request Headers","text":"<p>NSPS sends the following headers to the connector used for tracing and debugging:</p> <ul> <li>x-b3-traceid</li> <li>x-request-id</li> </ul> <p>The connector should process them and add them to all log messages related to the processing of a specific request. If the headers were not delivered, the connector should generate unique values (for example, use UUID-compatible format).</p>"}]}